"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zod";
exports.ids = ["vendor-chunks/zod"];
exports.modules = {

/***/ "(ssr)/./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   datetimeRegex: () => (/* binding */ datetimeRegex),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\r\n(function (util) {\r\n    util.assertEqual = (val) => val;\r\n    function assertIs(_arg) { }\r\n    util.assertIs = assertIs;\r\n    function assertNever(_x) {\r\n        throw new Error();\r\n    }\r\n    util.assertNever = assertNever;\r\n    util.arrayToEnum = (items) => {\r\n        const obj = {};\r\n        for (const item of items) {\r\n            obj[item] = item;\r\n        }\r\n        return obj;\r\n    };\r\n    util.getValidEnumValues = (obj) => {\r\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\r\n        const filtered = {};\r\n        for (const k of validKeys) {\r\n            filtered[k] = obj[k];\r\n        }\r\n        return util.objectValues(filtered);\r\n    };\r\n    util.objectValues = (obj) => {\r\n        return util.objectKeys(obj).map(function (e) {\r\n            return obj[e];\r\n        });\r\n    };\r\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\r\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\r\n        : (object) => {\r\n            const keys = [];\r\n            for (const key in object) {\r\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            return keys;\r\n        };\r\n    util.find = (arr, checker) => {\r\n        for (const item of arr) {\r\n            if (checker(item))\r\n                return item;\r\n        }\r\n        return undefined;\r\n    };\r\n    util.isInteger = typeof Number.isInteger === \"function\"\r\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\r\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\r\n    function joinValues(array, separator = \" | \") {\r\n        return array\r\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\r\n            .join(separator);\r\n    }\r\n    util.joinValues = joinValues;\r\n    util.jsonStringifyReplacer = (_, value) => {\r\n        if (typeof value === \"bigint\") {\r\n            return value.toString();\r\n        }\r\n        return value;\r\n    };\r\n})(util || (util = {}));\r\nvar objectUtil;\r\n(function (objectUtil) {\r\n    objectUtil.mergeShapes = (first, second) => {\r\n        return {\r\n            ...first,\r\n            ...second, // second overwrites first\r\n        };\r\n    };\r\n})(objectUtil || (objectUtil = {}));\r\nconst ZodParsedType = util.arrayToEnum([\r\n    \"string\",\r\n    \"nan\",\r\n    \"number\",\r\n    \"integer\",\r\n    \"float\",\r\n    \"boolean\",\r\n    \"date\",\r\n    \"bigint\",\r\n    \"symbol\",\r\n    \"function\",\r\n    \"undefined\",\r\n    \"null\",\r\n    \"array\",\r\n    \"object\",\r\n    \"unknown\",\r\n    \"promise\",\r\n    \"void\",\r\n    \"never\",\r\n    \"map\",\r\n    \"set\",\r\n]);\r\nconst getParsedType = (data) => {\r\n    const t = typeof data;\r\n    switch (t) {\r\n        case \"undefined\":\r\n            return ZodParsedType.undefined;\r\n        case \"string\":\r\n            return ZodParsedType.string;\r\n        case \"number\":\r\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\r\n        case \"boolean\":\r\n            return ZodParsedType.boolean;\r\n        case \"function\":\r\n            return ZodParsedType.function;\r\n        case \"bigint\":\r\n            return ZodParsedType.bigint;\r\n        case \"symbol\":\r\n            return ZodParsedType.symbol;\r\n        case \"object\":\r\n            if (Array.isArray(data)) {\r\n                return ZodParsedType.array;\r\n            }\r\n            if (data === null) {\r\n                return ZodParsedType.null;\r\n            }\r\n            if (data.then &&\r\n                typeof data.then === \"function\" &&\r\n                data.catch &&\r\n                typeof data.catch === \"function\") {\r\n                return ZodParsedType.promise;\r\n            }\r\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\r\n                return ZodParsedType.map;\r\n            }\r\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\r\n                return ZodParsedType.set;\r\n            }\r\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\r\n                return ZodParsedType.date;\r\n            }\r\n            return ZodParsedType.object;\r\n        default:\r\n            return ZodParsedType.unknown;\r\n    }\r\n};\r\n\r\nconst ZodIssueCode = util.arrayToEnum([\r\n    \"invalid_type\",\r\n    \"invalid_literal\",\r\n    \"custom\",\r\n    \"invalid_union\",\r\n    \"invalid_union_discriminator\",\r\n    \"invalid_enum_value\",\r\n    \"unrecognized_keys\",\r\n    \"invalid_arguments\",\r\n    \"invalid_return_type\",\r\n    \"invalid_date\",\r\n    \"invalid_string\",\r\n    \"too_small\",\r\n    \"too_big\",\r\n    \"invalid_intersection_types\",\r\n    \"not_multiple_of\",\r\n    \"not_finite\",\r\n]);\r\nconst quotelessJson = (obj) => {\r\n    const json = JSON.stringify(obj, null, 2);\r\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\r\n};\r\nclass ZodError extends Error {\r\n    constructor(issues) {\r\n        super();\r\n        this.issues = [];\r\n        this.addIssue = (sub) => {\r\n            this.issues = [...this.issues, sub];\r\n        };\r\n        this.addIssues = (subs = []) => {\r\n            this.issues = [...this.issues, ...subs];\r\n        };\r\n        const actualProto = new.target.prototype;\r\n        if (Object.setPrototypeOf) {\r\n            // eslint-disable-next-line ban/ban\r\n            Object.setPrototypeOf(this, actualProto);\r\n        }\r\n        else {\r\n            this.__proto__ = actualProto;\r\n        }\r\n        this.name = \"ZodError\";\r\n        this.issues = issues;\r\n    }\r\n    get errors() {\r\n        return this.issues;\r\n    }\r\n    format(_mapper) {\r\n        const mapper = _mapper ||\r\n            function (issue) {\r\n                return issue.message;\r\n            };\r\n        const fieldErrors = { _errors: [] };\r\n        const processError = (error) => {\r\n            for (const issue of error.issues) {\r\n                if (issue.code === \"invalid_union\") {\r\n                    issue.unionErrors.map(processError);\r\n                }\r\n                else if (issue.code === \"invalid_return_type\") {\r\n                    processError(issue.returnTypeError);\r\n                }\r\n                else if (issue.code === \"invalid_arguments\") {\r\n                    processError(issue.argumentsError);\r\n                }\r\n                else if (issue.path.length === 0) {\r\n                    fieldErrors._errors.push(mapper(issue));\r\n                }\r\n                else {\r\n                    let curr = fieldErrors;\r\n                    let i = 0;\r\n                    while (i < issue.path.length) {\r\n                        const el = issue.path[i];\r\n                        const terminal = i === issue.path.length - 1;\r\n                        if (!terminal) {\r\n                            curr[el] = curr[el] || { _errors: [] };\r\n                            // if (typeof el === \"string\") {\r\n                            //   curr[el] = curr[el] || { _errors: [] };\r\n                            // } else if (typeof el === \"number\") {\r\n                            //   const errorArray: any = [];\r\n                            //   errorArray._errors = [];\r\n                            //   curr[el] = curr[el] || errorArray;\r\n                            // }\r\n                        }\r\n                        else {\r\n                            curr[el] = curr[el] || { _errors: [] };\r\n                            curr[el]._errors.push(mapper(issue));\r\n                        }\r\n                        curr = curr[el];\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        processError(this);\r\n        return fieldErrors;\r\n    }\r\n    static assert(value) {\r\n        if (!(value instanceof ZodError)) {\r\n            throw new Error(`Not a ZodError: ${value}`);\r\n        }\r\n    }\r\n    toString() {\r\n        return this.message;\r\n    }\r\n    get message() {\r\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\r\n    }\r\n    get isEmpty() {\r\n        return this.issues.length === 0;\r\n    }\r\n    flatten(mapper = (issue) => issue.message) {\r\n        const fieldErrors = {};\r\n        const formErrors = [];\r\n        for (const sub of this.issues) {\r\n            if (sub.path.length > 0) {\r\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\r\n                fieldErrors[sub.path[0]].push(mapper(sub));\r\n            }\r\n            else {\r\n                formErrors.push(mapper(sub));\r\n            }\r\n        }\r\n        return { formErrors, fieldErrors };\r\n    }\r\n    get formErrors() {\r\n        return this.flatten();\r\n    }\r\n}\r\nZodError.create = (issues) => {\r\n    const error = new ZodError(issues);\r\n    return error;\r\n};\r\n\r\nconst errorMap = (issue, _ctx) => {\r\n    let message;\r\n    switch (issue.code) {\r\n        case ZodIssueCode.invalid_type:\r\n            if (issue.received === ZodParsedType.undefined) {\r\n                message = \"Required\";\r\n            }\r\n            else {\r\n                message = `Expected ${issue.expected}, received ${issue.received}`;\r\n            }\r\n            break;\r\n        case ZodIssueCode.invalid_literal:\r\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\r\n            break;\r\n        case ZodIssueCode.unrecognized_keys:\r\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\r\n            break;\r\n        case ZodIssueCode.invalid_union:\r\n            message = `Invalid input`;\r\n            break;\r\n        case ZodIssueCode.invalid_union_discriminator:\r\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\r\n            break;\r\n        case ZodIssueCode.invalid_enum_value:\r\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\r\n            break;\r\n        case ZodIssueCode.invalid_arguments:\r\n            message = `Invalid function arguments`;\r\n            break;\r\n        case ZodIssueCode.invalid_return_type:\r\n            message = `Invalid function return type`;\r\n            break;\r\n        case ZodIssueCode.invalid_date:\r\n            message = `Invalid date`;\r\n            break;\r\n        case ZodIssueCode.invalid_string:\r\n            if (typeof issue.validation === \"object\") {\r\n                if (\"includes\" in issue.validation) {\r\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\r\n                    if (typeof issue.validation.position === \"number\") {\r\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\r\n                    }\r\n                }\r\n                else if (\"startsWith\" in issue.validation) {\r\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\r\n                }\r\n                else if (\"endsWith\" in issue.validation) {\r\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\r\n                }\r\n                else {\r\n                    util.assertNever(issue.validation);\r\n                }\r\n            }\r\n            else if (issue.validation !== \"regex\") {\r\n                message = `Invalid ${issue.validation}`;\r\n            }\r\n            else {\r\n                message = \"Invalid\";\r\n            }\r\n            break;\r\n        case ZodIssueCode.too_small:\r\n            if (issue.type === \"array\")\r\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\r\n            else if (issue.type === \"string\")\r\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\r\n            else if (issue.type === \"number\")\r\n                message = `Number must be ${issue.exact\r\n                    ? `exactly equal to `\r\n                    : issue.inclusive\r\n                        ? `greater than or equal to `\r\n                        : `greater than `}${issue.minimum}`;\r\n            else if (issue.type === \"date\")\r\n                message = `Date must be ${issue.exact\r\n                    ? `exactly equal to `\r\n                    : issue.inclusive\r\n                        ? `greater than or equal to `\r\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\r\n            else\r\n                message = \"Invalid input\";\r\n            break;\r\n        case ZodIssueCode.too_big:\r\n            if (issue.type === \"array\")\r\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\r\n            else if (issue.type === \"string\")\r\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\r\n            else if (issue.type === \"number\")\r\n                message = `Number must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `less than or equal to`\r\n                        : `less than`} ${issue.maximum}`;\r\n            else if (issue.type === \"bigint\")\r\n                message = `BigInt must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `less than or equal to`\r\n                        : `less than`} ${issue.maximum}`;\r\n            else if (issue.type === \"date\")\r\n                message = `Date must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `smaller than or equal to`\r\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\r\n            else\r\n                message = \"Invalid input\";\r\n            break;\r\n        case ZodIssueCode.custom:\r\n            message = `Invalid input`;\r\n            break;\r\n        case ZodIssueCode.invalid_intersection_types:\r\n            message = `Intersection results could not be merged`;\r\n            break;\r\n        case ZodIssueCode.not_multiple_of:\r\n            message = `Number must be a multiple of ${issue.multipleOf}`;\r\n            break;\r\n        case ZodIssueCode.not_finite:\r\n            message = \"Number must be finite\";\r\n            break;\r\n        default:\r\n            message = _ctx.defaultError;\r\n            util.assertNever(issue);\r\n    }\r\n    return { message };\r\n};\r\n\r\nlet overrideErrorMap = errorMap;\r\nfunction setErrorMap(map) {\r\n    overrideErrorMap = map;\r\n}\r\nfunction getErrorMap() {\r\n    return overrideErrorMap;\r\n}\r\n\r\nconst makeIssue = (params) => {\r\n    const { data, path, errorMaps, issueData } = params;\r\n    const fullPath = [...path, ...(issueData.path || [])];\r\n    const fullIssue = {\r\n        ...issueData,\r\n        path: fullPath,\r\n    };\r\n    if (issueData.message !== undefined) {\r\n        return {\r\n            ...issueData,\r\n            path: fullPath,\r\n            message: issueData.message,\r\n        };\r\n    }\r\n    let errorMessage = \"\";\r\n    const maps = errorMaps\r\n        .filter((m) => !!m)\r\n        .slice()\r\n        .reverse();\r\n    for (const map of maps) {\r\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\r\n    }\r\n    return {\r\n        ...issueData,\r\n        path: fullPath,\r\n        message: errorMessage,\r\n    };\r\n};\r\nconst EMPTY_PATH = [];\r\nfunction addIssueToContext(ctx, issueData) {\r\n    const overrideMap = getErrorMap();\r\n    const issue = makeIssue({\r\n        issueData: issueData,\r\n        data: ctx.data,\r\n        path: ctx.path,\r\n        errorMaps: [\r\n            ctx.common.contextualErrorMap,\r\n            ctx.schemaErrorMap,\r\n            overrideMap,\r\n            overrideMap === errorMap ? undefined : errorMap, // then global default map\r\n        ].filter((x) => !!x),\r\n    });\r\n    ctx.common.issues.push(issue);\r\n}\r\nclass ParseStatus {\r\n    constructor() {\r\n        this.value = \"valid\";\r\n    }\r\n    dirty() {\r\n        if (this.value === \"valid\")\r\n            this.value = \"dirty\";\r\n    }\r\n    abort() {\r\n        if (this.value !== \"aborted\")\r\n            this.value = \"aborted\";\r\n    }\r\n    static mergeArray(status, results) {\r\n        const arrayValue = [];\r\n        for (const s of results) {\r\n            if (s.status === \"aborted\")\r\n                return INVALID;\r\n            if (s.status === \"dirty\")\r\n                status.dirty();\r\n            arrayValue.push(s.value);\r\n        }\r\n        return { status: status.value, value: arrayValue };\r\n    }\r\n    static async mergeObjectAsync(status, pairs) {\r\n        const syncPairs = [];\r\n        for (const pair of pairs) {\r\n            const key = await pair.key;\r\n            const value = await pair.value;\r\n            syncPairs.push({\r\n                key,\r\n                value,\r\n            });\r\n        }\r\n        return ParseStatus.mergeObjectSync(status, syncPairs);\r\n    }\r\n    static mergeObjectSync(status, pairs) {\r\n        const finalObject = {};\r\n        for (const pair of pairs) {\r\n            const { key, value } = pair;\r\n            if (key.status === \"aborted\")\r\n                return INVALID;\r\n            if (value.status === \"aborted\")\r\n                return INVALID;\r\n            if (key.status === \"dirty\")\r\n                status.dirty();\r\n            if (value.status === \"dirty\")\r\n                status.dirty();\r\n            if (key.value !== \"__proto__\" &&\r\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\r\n                finalObject[key.value] = value.value;\r\n            }\r\n        }\r\n        return { status: status.value, value: finalObject };\r\n    }\r\n}\r\nconst INVALID = Object.freeze({\r\n    status: \"aborted\",\r\n});\r\nconst DIRTY = (value) => ({ status: \"dirty\", value });\r\nconst OK = (value) => ({ status: \"valid\", value });\r\nconst isAborted = (x) => x.status === \"aborted\";\r\nconst isDirty = (x) => x.status === \"dirty\";\r\nconst isValid = (x) => x.status === \"valid\";\r\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\r\n\r\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nvar errorUtil;\r\n(function (errorUtil) {\r\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\r\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\r\n})(errorUtil || (errorUtil = {}));\r\n\r\nvar _ZodEnum_cache, _ZodNativeEnum_cache;\r\nclass ParseInputLazyPath {\r\n    constructor(parent, value, path, key) {\r\n        this._cachedPath = [];\r\n        this.parent = parent;\r\n        this.data = value;\r\n        this._path = path;\r\n        this._key = key;\r\n    }\r\n    get path() {\r\n        if (!this._cachedPath.length) {\r\n            if (this._key instanceof Array) {\r\n                this._cachedPath.push(...this._path, ...this._key);\r\n            }\r\n            else {\r\n                this._cachedPath.push(...this._path, this._key);\r\n            }\r\n        }\r\n        return this._cachedPath;\r\n    }\r\n}\r\nconst handleResult = (ctx, result) => {\r\n    if (isValid(result)) {\r\n        return { success: true, data: result.value };\r\n    }\r\n    else {\r\n        if (!ctx.common.issues.length) {\r\n            throw new Error(\"Validation failed but no issues detected.\");\r\n        }\r\n        return {\r\n            success: false,\r\n            get error() {\r\n                if (this._error)\r\n                    return this._error;\r\n                const error = new ZodError(ctx.common.issues);\r\n                this._error = error;\r\n                return this._error;\r\n            },\r\n        };\r\n    }\r\n};\r\nfunction processCreateParams(params) {\r\n    if (!params)\r\n        return {};\r\n    const { errorMap, invalid_type_error, required_error, description } = params;\r\n    if (errorMap && (invalid_type_error || required_error)) {\r\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\r\n    }\r\n    if (errorMap)\r\n        return { errorMap: errorMap, description };\r\n    const customMap = (iss, ctx) => {\r\n        var _a, _b;\r\n        const { message } = params;\r\n        if (iss.code === \"invalid_enum_value\") {\r\n            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\r\n        }\r\n        if (typeof ctx.data === \"undefined\") {\r\n            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\r\n        }\r\n        if (iss.code !== \"invalid_type\")\r\n            return { message: ctx.defaultError };\r\n        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\r\n    };\r\n    return { errorMap: customMap, description };\r\n}\r\nclass ZodType {\r\n    constructor(def) {\r\n        /** Alias of safeParseAsync */\r\n        this.spa = this.safeParseAsync;\r\n        this._def = def;\r\n        this.parse = this.parse.bind(this);\r\n        this.safeParse = this.safeParse.bind(this);\r\n        this.parseAsync = this.parseAsync.bind(this);\r\n        this.safeParseAsync = this.safeParseAsync.bind(this);\r\n        this.spa = this.spa.bind(this);\r\n        this.refine = this.refine.bind(this);\r\n        this.refinement = this.refinement.bind(this);\r\n        this.superRefine = this.superRefine.bind(this);\r\n        this.optional = this.optional.bind(this);\r\n        this.nullable = this.nullable.bind(this);\r\n        this.nullish = this.nullish.bind(this);\r\n        this.array = this.array.bind(this);\r\n        this.promise = this.promise.bind(this);\r\n        this.or = this.or.bind(this);\r\n        this.and = this.and.bind(this);\r\n        this.transform = this.transform.bind(this);\r\n        this.brand = this.brand.bind(this);\r\n        this.default = this.default.bind(this);\r\n        this.catch = this.catch.bind(this);\r\n        this.describe = this.describe.bind(this);\r\n        this.pipe = this.pipe.bind(this);\r\n        this.readonly = this.readonly.bind(this);\r\n        this.isNullable = this.isNullable.bind(this);\r\n        this.isOptional = this.isOptional.bind(this);\r\n    }\r\n    get description() {\r\n        return this._def.description;\r\n    }\r\n    _getType(input) {\r\n        return getParsedType(input.data);\r\n    }\r\n    _getOrReturnCtx(input, ctx) {\r\n        return (ctx || {\r\n            common: input.parent.common,\r\n            data: input.data,\r\n            parsedType: getParsedType(input.data),\r\n            schemaErrorMap: this._def.errorMap,\r\n            path: input.path,\r\n            parent: input.parent,\r\n        });\r\n    }\r\n    _processInputParams(input) {\r\n        return {\r\n            status: new ParseStatus(),\r\n            ctx: {\r\n                common: input.parent.common,\r\n                data: input.data,\r\n                parsedType: getParsedType(input.data),\r\n                schemaErrorMap: this._def.errorMap,\r\n                path: input.path,\r\n                parent: input.parent,\r\n            },\r\n        };\r\n    }\r\n    _parseSync(input) {\r\n        const result = this._parse(input);\r\n        if (isAsync(result)) {\r\n            throw new Error(\"Synchronous parse encountered promise.\");\r\n        }\r\n        return result;\r\n    }\r\n    _parseAsync(input) {\r\n        const result = this._parse(input);\r\n        return Promise.resolve(result);\r\n    }\r\n    parse(data, params) {\r\n        const result = this.safeParse(data, params);\r\n        if (result.success)\r\n            return result.data;\r\n        throw result.error;\r\n    }\r\n    safeParse(data, params) {\r\n        var _a;\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\r\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\r\n            },\r\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\r\n        return handleResult(ctx, result);\r\n    }\r\n    async parseAsync(data, params) {\r\n        const result = await this.safeParseAsync(data, params);\r\n        if (result.success)\r\n            return result.data;\r\n        throw result.error;\r\n    }\r\n    async safeParseAsync(data, params) {\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\r\n                async: true,\r\n            },\r\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\r\n        const result = await (isAsync(maybeAsyncResult)\r\n            ? maybeAsyncResult\r\n            : Promise.resolve(maybeAsyncResult));\r\n        return handleResult(ctx, result);\r\n    }\r\n    refine(check, message) {\r\n        const getIssueProperties = (val) => {\r\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\r\n                return { message };\r\n            }\r\n            else if (typeof message === \"function\") {\r\n                return message(val);\r\n            }\r\n            else {\r\n                return message;\r\n            }\r\n        };\r\n        return this._refinement((val, ctx) => {\r\n            const result = check(val);\r\n            const setError = () => ctx.addIssue({\r\n                code: ZodIssueCode.custom,\r\n                ...getIssueProperties(val),\r\n            });\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then((data) => {\r\n                    if (!data) {\r\n                        setError();\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                });\r\n            }\r\n            if (!result) {\r\n                setError();\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    refinement(check, refinementData) {\r\n        return this._refinement((val, ctx) => {\r\n            if (!check(val)) {\r\n                ctx.addIssue(typeof refinementData === \"function\"\r\n                    ? refinementData(val, ctx)\r\n                    : refinementData);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    _refinement(refinement) {\r\n        return new ZodEffects({\r\n            schema: this,\r\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n            effect: { type: \"refinement\", refinement },\r\n        });\r\n    }\r\n    superRefine(refinement) {\r\n        return this._refinement(refinement);\r\n    }\r\n    optional() {\r\n        return ZodOptional.create(this, this._def);\r\n    }\r\n    nullable() {\r\n        return ZodNullable.create(this, this._def);\r\n    }\r\n    nullish() {\r\n        return this.nullable().optional();\r\n    }\r\n    array() {\r\n        return ZodArray.create(this, this._def);\r\n    }\r\n    promise() {\r\n        return ZodPromise.create(this, this._def);\r\n    }\r\n    or(option) {\r\n        return ZodUnion.create([this, option], this._def);\r\n    }\r\n    and(incoming) {\r\n        return ZodIntersection.create(this, incoming, this._def);\r\n    }\r\n    transform(transform) {\r\n        return new ZodEffects({\r\n            ...processCreateParams(this._def),\r\n            schema: this,\r\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n            effect: { type: \"transform\", transform },\r\n        });\r\n    }\r\n    default(def) {\r\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\r\n        return new ZodDefault({\r\n            ...processCreateParams(this._def),\r\n            innerType: this,\r\n            defaultValue: defaultValueFunc,\r\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\r\n        });\r\n    }\r\n    brand() {\r\n        return new ZodBranded({\r\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\r\n            type: this,\r\n            ...processCreateParams(this._def),\r\n        });\r\n    }\r\n    catch(def) {\r\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\r\n        return new ZodCatch({\r\n            ...processCreateParams(this._def),\r\n            innerType: this,\r\n            catchValue: catchValueFunc,\r\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\r\n        });\r\n    }\r\n    describe(description) {\r\n        const This = this.constructor;\r\n        return new This({\r\n            ...this._def,\r\n            description,\r\n        });\r\n    }\r\n    pipe(target) {\r\n        return ZodPipeline.create(this, target);\r\n    }\r\n    readonly() {\r\n        return ZodReadonly.create(this);\r\n    }\r\n    isOptional() {\r\n        return this.safeParse(undefined).success;\r\n    }\r\n    isNullable() {\r\n        return this.safeParse(null).success;\r\n    }\r\n}\r\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\r\nconst cuid2Regex = /^[0-9a-z]+$/;\r\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\r\n// const uuidRegex =\r\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\r\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\r\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\r\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\r\n// from https://stackoverflow.com/a/46181/1550155\r\n// old version: too slow, didn't support unicode\r\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\r\n//old email regex\r\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\r\n// eslint-disable-next-line\r\n// const emailRegex =\r\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\r\n// const emailRegex =\r\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\r\n// const emailRegex =\r\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\r\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\r\n// const emailRegex =\r\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\r\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\r\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\r\nlet emojiRegex;\r\n// faster, simpler, safer\r\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\r\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\r\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\r\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\r\n// simple\r\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\r\n// no leap year validation\r\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\r\n// with leap year validation\r\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\r\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\r\nfunction timeRegexSource(args) {\r\n    // let regex = `\\\\d{2}:\\\\d{2}:\\\\d{2}`;\r\n    let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\r\n    if (args.precision) {\r\n        regex = `${regex}\\\\.\\\\d{${args.precision}}`;\r\n    }\r\n    else if (args.precision == null) {\r\n        regex = `${regex}(\\\\.\\\\d+)?`;\r\n    }\r\n    return regex;\r\n}\r\nfunction timeRegex(args) {\r\n    return new RegExp(`^${timeRegexSource(args)}$`);\r\n}\r\n// Adapted from https://stackoverflow.com/a/3143231\r\nfunction datetimeRegex(args) {\r\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\r\n    const opts = [];\r\n    opts.push(args.local ? `Z?` : `Z`);\r\n    if (args.offset)\r\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\r\n    regex = `${regex}(${opts.join(\"|\")})`;\r\n    return new RegExp(`^${regex}$`);\r\n}\r\nfunction isValidIP(ip, version) {\r\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\r\n        return true;\r\n    }\r\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nclass ZodString extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = String(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.string) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.string,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const status = new ParseStatus();\r\n        let ctx = undefined;\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                if (input.data.length < check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        minimum: check.value,\r\n                        type: \"string\",\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                if (input.data.length > check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        maximum: check.value,\r\n                        type: \"string\",\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"length\") {\r\n                const tooBig = input.data.length > check.value;\r\n                const tooSmall = input.data.length < check.value;\r\n                if (tooBig || tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    if (tooBig) {\r\n                        addIssueToContext(ctx, {\r\n                            code: ZodIssueCode.too_big,\r\n                            maximum: check.value,\r\n                            type: \"string\",\r\n                            inclusive: true,\r\n                            exact: true,\r\n                            message: check.message,\r\n                        });\r\n                    }\r\n                    else if (tooSmall) {\r\n                        addIssueToContext(ctx, {\r\n                            code: ZodIssueCode.too_small,\r\n                            minimum: check.value,\r\n                            type: \"string\",\r\n                            inclusive: true,\r\n                            exact: true,\r\n                            message: check.message,\r\n                        });\r\n                    }\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"email\") {\r\n                if (!emailRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"email\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"emoji\") {\r\n                if (!emojiRegex) {\r\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\r\n                }\r\n                if (!emojiRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"emoji\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"uuid\") {\r\n                if (!uuidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"uuid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"nanoid\") {\r\n                if (!nanoidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"nanoid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cuid\") {\r\n                if (!cuidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cuid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cuid2\") {\r\n                if (!cuid2Regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cuid2\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"ulid\") {\r\n                if (!ulidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"ulid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"url\") {\r\n                try {\r\n                    new URL(input.data);\r\n                }\r\n                catch (_a) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"url\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"regex\") {\r\n                check.regex.lastIndex = 0;\r\n                const testResult = check.regex.test(input.data);\r\n                if (!testResult) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"regex\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"trim\") {\r\n                input.data = input.data.trim();\r\n            }\r\n            else if (check.kind === \"includes\") {\r\n                if (!input.data.includes(check.value, check.position)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { includes: check.value, position: check.position },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"toLowerCase\") {\r\n                input.data = input.data.toLowerCase();\r\n            }\r\n            else if (check.kind === \"toUpperCase\") {\r\n                input.data = input.data.toUpperCase();\r\n            }\r\n            else if (check.kind === \"startsWith\") {\r\n                if (!input.data.startsWith(check.value)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { startsWith: check.value },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"endsWith\") {\r\n                if (!input.data.endsWith(check.value)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { endsWith: check.value },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"datetime\") {\r\n                const regex = datetimeRegex(check);\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"datetime\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"date\") {\r\n                const regex = dateRegex;\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"date\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"time\") {\r\n                const regex = timeRegex(check);\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"time\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"duration\") {\r\n                if (!durationRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"duration\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"ip\") {\r\n                if (!isValidIP(input.data, check.version)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"ip\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"base64\") {\r\n                if (!base64Regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"base64\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    _regex(regex, validation, message) {\r\n        return this.refinement((data) => regex.test(data), {\r\n            validation,\r\n            code: ZodIssueCode.invalid_string,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    email(message) {\r\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\r\n    }\r\n    url(message) {\r\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\r\n    }\r\n    emoji(message) {\r\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\r\n    }\r\n    uuid(message) {\r\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    nanoid(message) {\r\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    cuid(message) {\r\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    cuid2(message) {\r\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\r\n    }\r\n    ulid(message) {\r\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    base64(message) {\r\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\r\n    }\r\n    ip(options) {\r\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\r\n    }\r\n    datetime(options) {\r\n        var _a, _b;\r\n        if (typeof options === \"string\") {\r\n            return this._addCheck({\r\n                kind: \"datetime\",\r\n                precision: null,\r\n                offset: false,\r\n                local: false,\r\n                message: options,\r\n            });\r\n        }\r\n        return this._addCheck({\r\n            kind: \"datetime\",\r\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\r\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\r\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    date(message) {\r\n        return this._addCheck({ kind: \"date\", message });\r\n    }\r\n    time(options) {\r\n        if (typeof options === \"string\") {\r\n            return this._addCheck({\r\n                kind: \"time\",\r\n                precision: null,\r\n                message: options,\r\n            });\r\n        }\r\n        return this._addCheck({\r\n            kind: \"time\",\r\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    duration(message) {\r\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\r\n    }\r\n    regex(regex, message) {\r\n        return this._addCheck({\r\n            kind: \"regex\",\r\n            regex: regex,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    includes(value, options) {\r\n        return this._addCheck({\r\n            kind: \"includes\",\r\n            value: value,\r\n            position: options === null || options === void 0 ? void 0 : options.position,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    startsWith(value, message) {\r\n        return this._addCheck({\r\n            kind: \"startsWith\",\r\n            value: value,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    endsWith(value, message) {\r\n        return this._addCheck({\r\n            kind: \"endsWith\",\r\n            value: value,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    min(minLength, message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: minLength,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    max(maxLength, message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: maxLength,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    length(len, message) {\r\n        return this._addCheck({\r\n            kind: \"length\",\r\n            value: len,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    /**\r\n     * @deprecated Use z.string().min(1) instead.\r\n     * @see {@link ZodString.min}\r\n     */\r\n    nonempty(message) {\r\n        return this.min(1, errorUtil.errToObj(message));\r\n    }\r\n    trim() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"trim\" }],\r\n        });\r\n    }\r\n    toLowerCase() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\r\n        });\r\n    }\r\n    toUpperCase() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\r\n        });\r\n    }\r\n    get isDatetime() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\r\n    }\r\n    get isDate() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\r\n    }\r\n    get isTime() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\r\n    }\r\n    get isDuration() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\r\n    }\r\n    get isEmail() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\r\n    }\r\n    get isURL() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\r\n    }\r\n    get isEmoji() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\r\n    }\r\n    get isUUID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\r\n    }\r\n    get isNANOID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\r\n    }\r\n    get isCUID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\r\n    }\r\n    get isCUID2() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\r\n    }\r\n    get isULID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\r\n    }\r\n    get isIP() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\r\n    }\r\n    get isBase64() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\r\n    }\r\n    get minLength() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxLength() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\nZodString.create = (params) => {\r\n    var _a;\r\n    return new ZodString({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodString,\r\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\r\nfunction floatSafeRemainder(val, step) {\r\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\r\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\r\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\r\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\r\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\r\n    return (valInt % stepInt) / Math.pow(10, decCount);\r\n}\r\nclass ZodNumber extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.min = this.gte;\r\n        this.max = this.lte;\r\n        this.step = this.multipleOf;\r\n    }\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = Number(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.number) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.number,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        let ctx = undefined;\r\n        const status = new ParseStatus();\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"int\") {\r\n                if (!util.isInteger(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_type,\r\n                        expected: \"integer\",\r\n                        received: \"float\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"min\") {\r\n                const tooSmall = check.inclusive\r\n                    ? input.data < check.value\r\n                    : input.data <= check.value;\r\n                if (tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        minimum: check.value,\r\n                        type: \"number\",\r\n                        inclusive: check.inclusive,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                const tooBig = check.inclusive\r\n                    ? input.data > check.value\r\n                    : input.data >= check.value;\r\n                if (tooBig) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        maximum: check.value,\r\n                        type: \"number\",\r\n                        inclusive: check.inclusive,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"multipleOf\") {\r\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_multiple_of,\r\n                        multipleOf: check.value,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"finite\") {\r\n                if (!Number.isFinite(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_finite,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    gte(value, message) {\r\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\r\n    }\r\n    gt(value, message) {\r\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\r\n    }\r\n    lte(value, message) {\r\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\r\n    }\r\n    lt(value, message) {\r\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\r\n    }\r\n    setLimit(kind, value, inclusive, message) {\r\n        return new ZodNumber({\r\n            ...this._def,\r\n            checks: [\r\n                ...this._def.checks,\r\n                {\r\n                    kind,\r\n                    value,\r\n                    inclusive,\r\n                    message: errorUtil.toString(message),\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodNumber({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    int(message) {\r\n        return this._addCheck({\r\n            kind: \"int\",\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    positive(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: 0,\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    negative(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: 0,\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonpositive(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: 0,\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonnegative(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: 0,\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    multipleOf(value, message) {\r\n        return this._addCheck({\r\n            kind: \"multipleOf\",\r\n            value: value,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    finite(message) {\r\n        return this._addCheck({\r\n            kind: \"finite\",\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    safe(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            inclusive: true,\r\n            value: Number.MIN_SAFE_INTEGER,\r\n            message: errorUtil.toString(message),\r\n        })._addCheck({\r\n            kind: \"max\",\r\n            inclusive: true,\r\n            value: Number.MAX_SAFE_INTEGER,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minValue() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxValue() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    get isInt() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\r\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\r\n    }\r\n    get isFinite() {\r\n        let max = null, min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"finite\" ||\r\n                ch.kind === \"int\" ||\r\n                ch.kind === \"multipleOf\") {\r\n                return true;\r\n            }\r\n            else if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n            else if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return Number.isFinite(min) && Number.isFinite(max);\r\n    }\r\n}\r\nZodNumber.create = (params) => {\r\n    return new ZodNumber({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodBigInt extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.min = this.gte;\r\n        this.max = this.lte;\r\n    }\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = BigInt(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.bigint) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.bigint,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        let ctx = undefined;\r\n        const status = new ParseStatus();\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                const tooSmall = check.inclusive\r\n                    ? input.data < check.value\r\n                    : input.data <= check.value;\r\n                if (tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        type: \"bigint\",\r\n                        minimum: check.value,\r\n                        inclusive: check.inclusive,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                const tooBig = check.inclusive\r\n                    ? input.data > check.value\r\n                    : input.data >= check.value;\r\n                if (tooBig) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        type: \"bigint\",\r\n                        maximum: check.value,\r\n                        inclusive: check.inclusive,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"multipleOf\") {\r\n                if (input.data % check.value !== BigInt(0)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_multiple_of,\r\n                        multipleOf: check.value,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    gte(value, message) {\r\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\r\n    }\r\n    gt(value, message) {\r\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\r\n    }\r\n    lte(value, message) {\r\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\r\n    }\r\n    lt(value, message) {\r\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\r\n    }\r\n    setLimit(kind, value, inclusive, message) {\r\n        return new ZodBigInt({\r\n            ...this._def,\r\n            checks: [\r\n                ...this._def.checks,\r\n                {\r\n                    kind,\r\n                    value,\r\n                    inclusive,\r\n                    message: errorUtil.toString(message),\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodBigInt({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    positive(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: BigInt(0),\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    negative(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: BigInt(0),\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonpositive(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: BigInt(0),\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonnegative(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: BigInt(0),\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    multipleOf(value, message) {\r\n        return this._addCheck({\r\n            kind: \"multipleOf\",\r\n            value,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minValue() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxValue() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\nZodBigInt.create = (params) => {\r\n    var _a;\r\n    return new ZodBigInt({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\r\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodBoolean extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = Boolean(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.boolean) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.boolean,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodBoolean.create = (params) => {\r\n    return new ZodBoolean({\r\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodDate extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = new Date(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.date) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.date,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (isNaN(input.data.getTime())) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_date,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const status = new ParseStatus();\r\n        let ctx = undefined;\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                if (input.data.getTime() < check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        message: check.message,\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        minimum: check.value,\r\n                        type: \"date\",\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                if (input.data.getTime() > check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        message: check.message,\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        maximum: check.value,\r\n                        type: \"date\",\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return {\r\n            status: status.value,\r\n            value: new Date(input.data.getTime()),\r\n        };\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodDate({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    min(minDate, message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: minDate.getTime(),\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    max(maxDate, message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: maxDate.getTime(),\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minDate() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min != null ? new Date(min) : null;\r\n    }\r\n    get maxDate() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max != null ? new Date(max) : null;\r\n    }\r\n}\r\nZodDate.create = (params) => {\r\n    return new ZodDate({\r\n        checks: [],\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        typeName: ZodFirstPartyTypeKind.ZodDate,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodSymbol extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.symbol) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.symbol,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodSymbol.create = (params) => {\r\n    return new ZodSymbol({\r\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUndefined extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.undefined) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.undefined,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodUndefined.create = (params) => {\r\n    return new ZodUndefined({\r\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNull extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.null) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.null,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodNull.create = (params) => {\r\n    return new ZodNull({\r\n        typeName: ZodFirstPartyTypeKind.ZodNull,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodAny extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\r\n        this._any = true;\r\n    }\r\n    _parse(input) {\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodAny.create = (params) => {\r\n    return new ZodAny({\r\n        typeName: ZodFirstPartyTypeKind.ZodAny,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUnknown extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        // required\r\n        this._unknown = true;\r\n    }\r\n    _parse(input) {\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodUnknown.create = (params) => {\r\n    return new ZodUnknown({\r\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNever extends ZodType {\r\n    _parse(input) {\r\n        const ctx = this._getOrReturnCtx(input);\r\n        addIssueToContext(ctx, {\r\n            code: ZodIssueCode.invalid_type,\r\n            expected: ZodParsedType.never,\r\n            received: ctx.parsedType,\r\n        });\r\n        return INVALID;\r\n    }\r\n}\r\nZodNever.create = (params) => {\r\n    return new ZodNever({\r\n        typeName: ZodFirstPartyTypeKind.ZodNever,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodVoid extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.undefined) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.void,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodVoid.create = (params) => {\r\n    return new ZodVoid({\r\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodArray extends ZodType {\r\n    _parse(input) {\r\n        const { ctx, status } = this._processInputParams(input);\r\n        const def = this._def;\r\n        if (ctx.parsedType !== ZodParsedType.array) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.array,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (def.exactLength !== null) {\r\n            const tooBig = ctx.data.length > def.exactLength.value;\r\n            const tooSmall = ctx.data.length < def.exactLength.value;\r\n            if (tooBig || tooSmall) {\r\n                addIssueToContext(ctx, {\r\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\r\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\r\n                    maximum: (tooBig ? def.exactLength.value : undefined),\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: true,\r\n                    message: def.exactLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.minLength !== null) {\r\n            if (ctx.data.length < def.minLength.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_small,\r\n                    minimum: def.minLength.value,\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.minLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.maxLength !== null) {\r\n            if (ctx.data.length > def.maxLength.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_big,\r\n                    maximum: def.maxLength.value,\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.maxLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.all([...ctx.data].map((item, i) => {\r\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\r\n            })).then((result) => {\r\n                return ParseStatus.mergeArray(status, result);\r\n            });\r\n        }\r\n        const result = [...ctx.data].map((item, i) => {\r\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\r\n        });\r\n        return ParseStatus.mergeArray(status, result);\r\n    }\r\n    get element() {\r\n        return this._def.type;\r\n    }\r\n    min(minLength, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            minLength: { value: minLength, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    max(maxLength, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    length(len, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            exactLength: { value: len, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    nonempty(message) {\r\n        return this.min(1, message);\r\n    }\r\n}\r\nZodArray.create = (schema, params) => {\r\n    return new ZodArray({\r\n        type: schema,\r\n        minLength: null,\r\n        maxLength: null,\r\n        exactLength: null,\r\n        typeName: ZodFirstPartyTypeKind.ZodArray,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction deepPartialify(schema) {\r\n    if (schema instanceof ZodObject) {\r\n        const newShape = {};\r\n        for (const key in schema.shape) {\r\n            const fieldSchema = schema.shape[key];\r\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\r\n        }\r\n        return new ZodObject({\r\n            ...schema._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    else if (schema instanceof ZodArray) {\r\n        return new ZodArray({\r\n            ...schema._def,\r\n            type: deepPartialify(schema.element),\r\n        });\r\n    }\r\n    else if (schema instanceof ZodOptional) {\r\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\r\n    }\r\n    else if (schema instanceof ZodNullable) {\r\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\r\n    }\r\n    else if (schema instanceof ZodTuple) {\r\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\r\n    }\r\n    else {\r\n        return schema;\r\n    }\r\n}\r\nclass ZodObject extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._cached = null;\r\n        /**\r\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\r\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\r\n         */\r\n        this.nonstrict = this.passthrough;\r\n        // extend<\r\n        //   Augmentation extends ZodRawShape,\r\n        //   NewOutput extends util.flatten<{\r\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\r\n        //       ? Augmentation[k][\"_output\"]\r\n        //       : k extends keyof Output\r\n        //       ? Output[k]\r\n        //       : never;\r\n        //   }>,\r\n        //   NewInput extends util.flatten<{\r\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\r\n        //       ? Augmentation[k][\"_input\"]\r\n        //       : k extends keyof Input\r\n        //       ? Input[k]\r\n        //       : never;\r\n        //   }>\r\n        // >(\r\n        //   augmentation: Augmentation\r\n        // ): ZodObject<\r\n        //   extendShape<T, Augmentation>,\r\n        //   UnknownKeys,\r\n        //   Catchall,\r\n        //   NewOutput,\r\n        //   NewInput\r\n        // > {\r\n        //   return new ZodObject({\r\n        //     ...this._def,\r\n        //     shape: () => ({\r\n        //       ...this._def.shape(),\r\n        //       ...augmentation,\r\n        //     }),\r\n        //   }) as any;\r\n        // }\r\n        /**\r\n         * @deprecated Use `.extend` instead\r\n         *  */\r\n        this.augment = this.extend;\r\n    }\r\n    _getCached() {\r\n        if (this._cached !== null)\r\n            return this._cached;\r\n        const shape = this._def.shape();\r\n        const keys = util.objectKeys(shape);\r\n        return (this._cached = { shape, keys });\r\n    }\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.object) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const { shape, keys: shapeKeys } = this._getCached();\r\n        const extraKeys = [];\r\n        if (!(this._def.catchall instanceof ZodNever &&\r\n            this._def.unknownKeys === \"strip\")) {\r\n            for (const key in ctx.data) {\r\n                if (!shapeKeys.includes(key)) {\r\n                    extraKeys.push(key);\r\n                }\r\n            }\r\n        }\r\n        const pairs = [];\r\n        for (const key of shapeKeys) {\r\n            const keyValidator = shape[key];\r\n            const value = ctx.data[key];\r\n            pairs.push({\r\n                key: { status: \"valid\", value: key },\r\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\r\n                alwaysSet: key in ctx.data,\r\n            });\r\n        }\r\n        if (this._def.catchall instanceof ZodNever) {\r\n            const unknownKeys = this._def.unknownKeys;\r\n            if (unknownKeys === \"passthrough\") {\r\n                for (const key of extraKeys) {\r\n                    pairs.push({\r\n                        key: { status: \"valid\", value: key },\r\n                        value: { status: \"valid\", value: ctx.data[key] },\r\n                    });\r\n                }\r\n            }\r\n            else if (unknownKeys === \"strict\") {\r\n                if (extraKeys.length > 0) {\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.unrecognized_keys,\r\n                        keys: extraKeys,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (unknownKeys === \"strip\") ;\r\n            else {\r\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\r\n            }\r\n        }\r\n        else {\r\n            // run catchall validation\r\n            const catchall = this._def.catchall;\r\n            for (const key of extraKeys) {\r\n                const value = ctx.data[key];\r\n                pairs.push({\r\n                    key: { status: \"valid\", value: key },\r\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\r\n                    ),\r\n                    alwaysSet: key in ctx.data,\r\n                });\r\n            }\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.resolve()\r\n                .then(async () => {\r\n                const syncPairs = [];\r\n                for (const pair of pairs) {\r\n                    const key = await pair.key;\r\n                    const value = await pair.value;\r\n                    syncPairs.push({\r\n                        key,\r\n                        value,\r\n                        alwaysSet: pair.alwaysSet,\r\n                    });\r\n                }\r\n                return syncPairs;\r\n            })\r\n                .then((syncPairs) => {\r\n                return ParseStatus.mergeObjectSync(status, syncPairs);\r\n            });\r\n        }\r\n        else {\r\n            return ParseStatus.mergeObjectSync(status, pairs);\r\n        }\r\n    }\r\n    get shape() {\r\n        return this._def.shape();\r\n    }\r\n    strict(message) {\r\n        errorUtil.errToObj;\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"strict\",\r\n            ...(message !== undefined\r\n                ? {\r\n                    errorMap: (issue, ctx) => {\r\n                        var _a, _b, _c, _d;\r\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\r\n                        if (issue.code === \"unrecognized_keys\")\r\n                            return {\r\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\r\n                            };\r\n                        return {\r\n                            message: defaultError,\r\n                        };\r\n                    },\r\n                }\r\n                : {}),\r\n        });\r\n    }\r\n    strip() {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"strip\",\r\n        });\r\n    }\r\n    passthrough() {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"passthrough\",\r\n        });\r\n    }\r\n    // const AugmentFactory =\r\n    //   <Def extends ZodObjectDef>(def: Def) =>\r\n    //   <Augmentation extends ZodRawShape>(\r\n    //     augmentation: Augmentation\r\n    //   ): ZodObject<\r\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\r\n    //     Def[\"unknownKeys\"],\r\n    //     Def[\"catchall\"]\r\n    //   > => {\r\n    //     return new ZodObject({\r\n    //       ...def,\r\n    //       shape: () => ({\r\n    //         ...def.shape(),\r\n    //         ...augmentation,\r\n    //       }),\r\n    //     }) as any;\r\n    //   };\r\n    extend(augmentation) {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => ({\r\n                ...this._def.shape(),\r\n                ...augmentation,\r\n            }),\r\n        });\r\n    }\r\n    /**\r\n     * Prior to zod@1.0.12 there was a bug in the\r\n     * inferred type of merged objects. Please\r\n     * upgrade if you are experiencing issues.\r\n     */\r\n    merge(merging) {\r\n        const merged = new ZodObject({\r\n            unknownKeys: merging._def.unknownKeys,\r\n            catchall: merging._def.catchall,\r\n            shape: () => ({\r\n                ...this._def.shape(),\r\n                ...merging._def.shape(),\r\n            }),\r\n            typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        });\r\n        return merged;\r\n    }\r\n    // merge<\r\n    //   Incoming extends AnyZodObject,\r\n    //   Augmentation extends Incoming[\"shape\"],\r\n    //   NewOutput extends {\r\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\r\n    //       ? Augmentation[k][\"_output\"]\r\n    //       : k extends keyof Output\r\n    //       ? Output[k]\r\n    //       : never;\r\n    //   },\r\n    //   NewInput extends {\r\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\r\n    //       ? Augmentation[k][\"_input\"]\r\n    //       : k extends keyof Input\r\n    //       ? Input[k]\r\n    //       : never;\r\n    //   }\r\n    // >(\r\n    //   merging: Incoming\r\n    // ): ZodObject<\r\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\r\n    //   Incoming[\"_def\"][\"unknownKeys\"],\r\n    //   Incoming[\"_def\"][\"catchall\"],\r\n    //   NewOutput,\r\n    //   NewInput\r\n    // > {\r\n    //   const merged: any = new ZodObject({\r\n    //     unknownKeys: merging._def.unknownKeys,\r\n    //     catchall: merging._def.catchall,\r\n    //     shape: () =>\r\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\r\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\r\n    //   }) as any;\r\n    //   return merged;\r\n    // }\r\n    setKey(key, schema) {\r\n        return this.augment({ [key]: schema });\r\n    }\r\n    // merge<Incoming extends AnyZodObject>(\r\n    //   merging: Incoming\r\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\r\n    // ZodObject<\r\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\r\n    //   Incoming[\"_def\"][\"unknownKeys\"],\r\n    //   Incoming[\"_def\"][\"catchall\"]\r\n    // > {\r\n    //   // const mergedShape = objectUtil.mergeShapes(\r\n    //   //   this._def.shape(),\r\n    //   //   merging._def.shape()\r\n    //   // );\r\n    //   const merged: any = new ZodObject({\r\n    //     unknownKeys: merging._def.unknownKeys,\r\n    //     catchall: merging._def.catchall,\r\n    //     shape: () =>\r\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\r\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\r\n    //   }) as any;\r\n    //   return merged;\r\n    // }\r\n    catchall(index) {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            catchall: index,\r\n        });\r\n    }\r\n    pick(mask) {\r\n        const shape = {};\r\n        util.objectKeys(mask).forEach((key) => {\r\n            if (mask[key] && this.shape[key]) {\r\n                shape[key] = this.shape[key];\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => shape,\r\n        });\r\n    }\r\n    omit(mask) {\r\n        const shape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            if (!mask[key]) {\r\n                shape[key] = this.shape[key];\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => shape,\r\n        });\r\n    }\r\n    /**\r\n     * @deprecated\r\n     */\r\n    deepPartial() {\r\n        return deepPartialify(this);\r\n    }\r\n    partial(mask) {\r\n        const newShape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            const fieldSchema = this.shape[key];\r\n            if (mask && !mask[key]) {\r\n                newShape[key] = fieldSchema;\r\n            }\r\n            else {\r\n                newShape[key] = fieldSchema.optional();\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    required(mask) {\r\n        const newShape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            if (mask && !mask[key]) {\r\n                newShape[key] = this.shape[key];\r\n            }\r\n            else {\r\n                const fieldSchema = this.shape[key];\r\n                let newField = fieldSchema;\r\n                while (newField instanceof ZodOptional) {\r\n                    newField = newField._def.innerType;\r\n                }\r\n                newShape[key] = newField;\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    keyof() {\r\n        return createZodEnum(util.objectKeys(this.shape));\r\n    }\r\n}\r\nZodObject.create = (shape, params) => {\r\n    return new ZodObject({\r\n        shape: () => shape,\r\n        unknownKeys: \"strip\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodObject.strictCreate = (shape, params) => {\r\n    return new ZodObject({\r\n        shape: () => shape,\r\n        unknownKeys: \"strict\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodObject.lazycreate = (shape, params) => {\r\n    return new ZodObject({\r\n        shape,\r\n        unknownKeys: \"strip\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUnion extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const options = this._def.options;\r\n        function handleResults(results) {\r\n            // return first issue-free validation if it exists\r\n            for (const result of results) {\r\n                if (result.result.status === \"valid\") {\r\n                    return result.result;\r\n                }\r\n            }\r\n            for (const result of results) {\r\n                if (result.result.status === \"dirty\") {\r\n                    // add issues from dirty option\r\n                    ctx.common.issues.push(...result.ctx.common.issues);\r\n                    return result.result;\r\n                }\r\n            }\r\n            // return invalid\r\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union,\r\n                unionErrors,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.all(options.map(async (option) => {\r\n                const childCtx = {\r\n                    ...ctx,\r\n                    common: {\r\n                        ...ctx.common,\r\n                        issues: [],\r\n                    },\r\n                    parent: null,\r\n                };\r\n                return {\r\n                    result: await option._parseAsync({\r\n                        data: ctx.data,\r\n                        path: ctx.path,\r\n                        parent: childCtx,\r\n                    }),\r\n                    ctx: childCtx,\r\n                };\r\n            })).then(handleResults);\r\n        }\r\n        else {\r\n            let dirty = undefined;\r\n            const issues = [];\r\n            for (const option of options) {\r\n                const childCtx = {\r\n                    ...ctx,\r\n                    common: {\r\n                        ...ctx.common,\r\n                        issues: [],\r\n                    },\r\n                    parent: null,\r\n                };\r\n                const result = option._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: childCtx,\r\n                });\r\n                if (result.status === \"valid\") {\r\n                    return result;\r\n                }\r\n                else if (result.status === \"dirty\" && !dirty) {\r\n                    dirty = { result, ctx: childCtx };\r\n                }\r\n                if (childCtx.common.issues.length) {\r\n                    issues.push(childCtx.common.issues);\r\n                }\r\n            }\r\n            if (dirty) {\r\n                ctx.common.issues.push(...dirty.ctx.common.issues);\r\n                return dirty.result;\r\n            }\r\n            const unionErrors = issues.map((issues) => new ZodError(issues));\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union,\r\n                unionErrors,\r\n            });\r\n            return INVALID;\r\n        }\r\n    }\r\n    get options() {\r\n        return this._def.options;\r\n    }\r\n}\r\nZodUnion.create = (types, params) => {\r\n    return new ZodUnion({\r\n        options: types,\r\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n/////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////\r\n//////////                                 //////////\r\n//////////      ZodDiscriminatedUnion      //////////\r\n//////////                                 //////////\r\n/////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////\r\nconst getDiscriminator = (type) => {\r\n    if (type instanceof ZodLazy) {\r\n        return getDiscriminator(type.schema);\r\n    }\r\n    else if (type instanceof ZodEffects) {\r\n        return getDiscriminator(type.innerType());\r\n    }\r\n    else if (type instanceof ZodLiteral) {\r\n        return [type.value];\r\n    }\r\n    else if (type instanceof ZodEnum) {\r\n        return type.options;\r\n    }\r\n    else if (type instanceof ZodNativeEnum) {\r\n        // eslint-disable-next-line ban/ban\r\n        return util.objectValues(type.enum);\r\n    }\r\n    else if (type instanceof ZodDefault) {\r\n        return getDiscriminator(type._def.innerType);\r\n    }\r\n    else if (type instanceof ZodUndefined) {\r\n        return [undefined];\r\n    }\r\n    else if (type instanceof ZodNull) {\r\n        return [null];\r\n    }\r\n    else if (type instanceof ZodOptional) {\r\n        return [undefined, ...getDiscriminator(type.unwrap())];\r\n    }\r\n    else if (type instanceof ZodNullable) {\r\n        return [null, ...getDiscriminator(type.unwrap())];\r\n    }\r\n    else if (type instanceof ZodBranded) {\r\n        return getDiscriminator(type.unwrap());\r\n    }\r\n    else if (type instanceof ZodReadonly) {\r\n        return getDiscriminator(type.unwrap());\r\n    }\r\n    else if (type instanceof ZodCatch) {\r\n        return getDiscriminator(type._def.innerType);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n};\r\nclass ZodDiscriminatedUnion extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.object) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const discriminator = this.discriminator;\r\n        const discriminatorValue = ctx.data[discriminator];\r\n        const option = this.optionsMap.get(discriminatorValue);\r\n        if (!option) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union_discriminator,\r\n                options: Array.from(this.optionsMap.keys()),\r\n                path: [discriminator],\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.common.async) {\r\n            return option._parseAsync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n        }\r\n        else {\r\n            return option._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n        }\r\n    }\r\n    get discriminator() {\r\n        return this._def.discriminator;\r\n    }\r\n    get options() {\r\n        return this._def.options;\r\n    }\r\n    get optionsMap() {\r\n        return this._def.optionsMap;\r\n    }\r\n    /**\r\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\r\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\r\n     * have a different value for each object in the union.\r\n     * @param discriminator the name of the discriminator property\r\n     * @param types an array of object schemas\r\n     * @param params\r\n     */\r\n    static create(discriminator, options, params) {\r\n        // Get all the valid discriminator values\r\n        const optionsMap = new Map();\r\n        // try {\r\n        for (const type of options) {\r\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\r\n            if (!discriminatorValues.length) {\r\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\r\n            }\r\n            for (const value of discriminatorValues) {\r\n                if (optionsMap.has(value)) {\r\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\r\n                }\r\n                optionsMap.set(value, type);\r\n            }\r\n        }\r\n        return new ZodDiscriminatedUnion({\r\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\r\n            discriminator,\r\n            options,\r\n            optionsMap,\r\n            ...processCreateParams(params),\r\n        });\r\n    }\r\n}\r\nfunction mergeValues(a, b) {\r\n    const aType = getParsedType(a);\r\n    const bType = getParsedType(b);\r\n    if (a === b) {\r\n        return { valid: true, data: a };\r\n    }\r\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\r\n        const bKeys = util.objectKeys(b);\r\n        const sharedKeys = util\r\n            .objectKeys(a)\r\n            .filter((key) => bKeys.indexOf(key) !== -1);\r\n        const newObj = { ...a, ...b };\r\n        for (const key of sharedKeys) {\r\n            const sharedValue = mergeValues(a[key], b[key]);\r\n            if (!sharedValue.valid) {\r\n                return { valid: false };\r\n            }\r\n            newObj[key] = sharedValue.data;\r\n        }\r\n        return { valid: true, data: newObj };\r\n    }\r\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\r\n        if (a.length !== b.length) {\r\n            return { valid: false };\r\n        }\r\n        const newArray = [];\r\n        for (let index = 0; index < a.length; index++) {\r\n            const itemA = a[index];\r\n            const itemB = b[index];\r\n            const sharedValue = mergeValues(itemA, itemB);\r\n            if (!sharedValue.valid) {\r\n                return { valid: false };\r\n            }\r\n            newArray.push(sharedValue.data);\r\n        }\r\n        return { valid: true, data: newArray };\r\n    }\r\n    else if (aType === ZodParsedType.date &&\r\n        bType === ZodParsedType.date &&\r\n        +a === +b) {\r\n        return { valid: true, data: a };\r\n    }\r\n    else {\r\n        return { valid: false };\r\n    }\r\n}\r\nclass ZodIntersection extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const handleParsed = (parsedLeft, parsedRight) => {\r\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\r\n                return INVALID;\r\n            }\r\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\r\n            if (!merged.valid) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.invalid_intersection_types,\r\n                });\r\n                return INVALID;\r\n            }\r\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\r\n                status.dirty();\r\n            }\r\n            return { status: status.value, value: merged.data };\r\n        };\r\n        if (ctx.common.async) {\r\n            return Promise.all([\r\n                this._def.left._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                }),\r\n                this._def.right._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                }),\r\n            ]).then(([left, right]) => handleParsed(left, right));\r\n        }\r\n        else {\r\n            return handleParsed(this._def.left._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            }), this._def.right._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            }));\r\n        }\r\n    }\r\n}\r\nZodIntersection.create = (left, right, params) => {\r\n    return new ZodIntersection({\r\n        left: left,\r\n        right: right,\r\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodTuple extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.array) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.array,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.data.length < this._def.items.length) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.too_small,\r\n                minimum: this._def.items.length,\r\n                inclusive: true,\r\n                exact: false,\r\n                type: \"array\",\r\n            });\r\n            return INVALID;\r\n        }\r\n        const rest = this._def.rest;\r\n        if (!rest && ctx.data.length > this._def.items.length) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.too_big,\r\n                maximum: this._def.items.length,\r\n                inclusive: true,\r\n                exact: false,\r\n                type: \"array\",\r\n            });\r\n            status.dirty();\r\n        }\r\n        const items = [...ctx.data]\r\n            .map((item, itemIndex) => {\r\n            const schema = this._def.items[itemIndex] || this._def.rest;\r\n            if (!schema)\r\n                return null;\r\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\r\n        })\r\n            .filter((x) => !!x); // filter nulls\r\n        if (ctx.common.async) {\r\n            return Promise.all(items).then((results) => {\r\n                return ParseStatus.mergeArray(status, results);\r\n            });\r\n        }\r\n        else {\r\n            return ParseStatus.mergeArray(status, items);\r\n        }\r\n    }\r\n    get items() {\r\n        return this._def.items;\r\n    }\r\n    rest(rest) {\r\n        return new ZodTuple({\r\n            ...this._def,\r\n            rest,\r\n        });\r\n    }\r\n}\r\nZodTuple.create = (schemas, params) => {\r\n    if (!Array.isArray(schemas)) {\r\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\r\n    }\r\n    return new ZodTuple({\r\n        items: schemas,\r\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\r\n        rest: null,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodRecord extends ZodType {\r\n    get keySchema() {\r\n        return this._def.keyType;\r\n    }\r\n    get valueSchema() {\r\n        return this._def.valueType;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.object) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const pairs = [];\r\n        const keyType = this._def.keyType;\r\n        const valueType = this._def.valueType;\r\n        for (const key in ctx.data) {\r\n            pairs.push({\r\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\r\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\r\n                alwaysSet: key in ctx.data,\r\n            });\r\n        }\r\n        if (ctx.common.async) {\r\n            return ParseStatus.mergeObjectAsync(status, pairs);\r\n        }\r\n        else {\r\n            return ParseStatus.mergeObjectSync(status, pairs);\r\n        }\r\n    }\r\n    get element() {\r\n        return this._def.valueType;\r\n    }\r\n    static create(first, second, third) {\r\n        if (second instanceof ZodType) {\r\n            return new ZodRecord({\r\n                keyType: first,\r\n                valueType: second,\r\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\r\n                ...processCreateParams(third),\r\n            });\r\n        }\r\n        return new ZodRecord({\r\n            keyType: ZodString.create(),\r\n            valueType: first,\r\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\r\n            ...processCreateParams(second),\r\n        });\r\n    }\r\n}\r\nclass ZodMap extends ZodType {\r\n    get keySchema() {\r\n        return this._def.keyType;\r\n    }\r\n    get valueSchema() {\r\n        return this._def.valueType;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.map) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.map,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const keyType = this._def.keyType;\r\n        const valueType = this._def.valueType;\r\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\r\n            return {\r\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\r\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\r\n            };\r\n        });\r\n        if (ctx.common.async) {\r\n            const finalMap = new Map();\r\n            return Promise.resolve().then(async () => {\r\n                for (const pair of pairs) {\r\n                    const key = await pair.key;\r\n                    const value = await pair.value;\r\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\r\n                        return INVALID;\r\n                    }\r\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\r\n                        status.dirty();\r\n                    }\r\n                    finalMap.set(key.value, value.value);\r\n                }\r\n                return { status: status.value, value: finalMap };\r\n            });\r\n        }\r\n        else {\r\n            const finalMap = new Map();\r\n            for (const pair of pairs) {\r\n                const key = pair.key;\r\n                const value = pair.value;\r\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\r\n                    return INVALID;\r\n                }\r\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\r\n                    status.dirty();\r\n                }\r\n                finalMap.set(key.value, value.value);\r\n            }\r\n            return { status: status.value, value: finalMap };\r\n        }\r\n    }\r\n}\r\nZodMap.create = (keyType, valueType, params) => {\r\n    return new ZodMap({\r\n        valueType,\r\n        keyType,\r\n        typeName: ZodFirstPartyTypeKind.ZodMap,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodSet extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.set) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.set,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const def = this._def;\r\n        if (def.minSize !== null) {\r\n            if (ctx.data.size < def.minSize.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_small,\r\n                    minimum: def.minSize.value,\r\n                    type: \"set\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.minSize.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.maxSize !== null) {\r\n            if (ctx.data.size > def.maxSize.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_big,\r\n                    maximum: def.maxSize.value,\r\n                    type: \"set\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.maxSize.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        const valueType = this._def.valueType;\r\n        function finalizeSet(elements) {\r\n            const parsedSet = new Set();\r\n            for (const element of elements) {\r\n                if (element.status === \"aborted\")\r\n                    return INVALID;\r\n                if (element.status === \"dirty\")\r\n                    status.dirty();\r\n                parsedSet.add(element.value);\r\n            }\r\n            return { status: status.value, value: parsedSet };\r\n        }\r\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\r\n        if (ctx.common.async) {\r\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\r\n        }\r\n        else {\r\n            return finalizeSet(elements);\r\n        }\r\n    }\r\n    min(minSize, message) {\r\n        return new ZodSet({\r\n            ...this._def,\r\n            minSize: { value: minSize, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    max(maxSize, message) {\r\n        return new ZodSet({\r\n            ...this._def,\r\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    size(size, message) {\r\n        return this.min(size, message).max(size, message);\r\n    }\r\n    nonempty(message) {\r\n        return this.min(1, message);\r\n    }\r\n}\r\nZodSet.create = (valueType, params) => {\r\n    return new ZodSet({\r\n        valueType,\r\n        minSize: null,\r\n        maxSize: null,\r\n        typeName: ZodFirstPartyTypeKind.ZodSet,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodFunction extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.validate = this.implement;\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.function) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.function,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        function makeArgsIssue(args, error) {\r\n            return makeIssue({\r\n                data: args,\r\n                path: ctx.path,\r\n                errorMaps: [\r\n                    ctx.common.contextualErrorMap,\r\n                    ctx.schemaErrorMap,\r\n                    getErrorMap(),\r\n                    errorMap,\r\n                ].filter((x) => !!x),\r\n                issueData: {\r\n                    code: ZodIssueCode.invalid_arguments,\r\n                    argumentsError: error,\r\n                },\r\n            });\r\n        }\r\n        function makeReturnsIssue(returns, error) {\r\n            return makeIssue({\r\n                data: returns,\r\n                path: ctx.path,\r\n                errorMaps: [\r\n                    ctx.common.contextualErrorMap,\r\n                    ctx.schemaErrorMap,\r\n                    getErrorMap(),\r\n                    errorMap,\r\n                ].filter((x) => !!x),\r\n                issueData: {\r\n                    code: ZodIssueCode.invalid_return_type,\r\n                    returnTypeError: error,\r\n                },\r\n            });\r\n        }\r\n        const params = { errorMap: ctx.common.contextualErrorMap };\r\n        const fn = ctx.data;\r\n        if (this._def.returns instanceof ZodPromise) {\r\n            // Would love a way to avoid disabling this rule, but we need\r\n            // an alias (using an arrow function was what caused 2651).\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const me = this;\r\n            return OK(async function (...args) {\r\n                const error = new ZodError([]);\r\n                const parsedArgs = await me._def.args\r\n                    .parseAsync(args, params)\r\n                    .catch((e) => {\r\n                    error.addIssue(makeArgsIssue(args, e));\r\n                    throw error;\r\n                });\r\n                const result = await Reflect.apply(fn, this, parsedArgs);\r\n                const parsedReturns = await me._def.returns._def.type\r\n                    .parseAsync(result, params)\r\n                    .catch((e) => {\r\n                    error.addIssue(makeReturnsIssue(result, e));\r\n                    throw error;\r\n                });\r\n                return parsedReturns;\r\n            });\r\n        }\r\n        else {\r\n            // Would love a way to avoid disabling this rule, but we need\r\n            // an alias (using an arrow function was what caused 2651).\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const me = this;\r\n            return OK(function (...args) {\r\n                const parsedArgs = me._def.args.safeParse(args, params);\r\n                if (!parsedArgs.success) {\r\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\r\n                }\r\n                const result = Reflect.apply(fn, this, parsedArgs.data);\r\n                const parsedReturns = me._def.returns.safeParse(result, params);\r\n                if (!parsedReturns.success) {\r\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\r\n                }\r\n                return parsedReturns.data;\r\n            });\r\n        }\r\n    }\r\n    parameters() {\r\n        return this._def.args;\r\n    }\r\n    returnType() {\r\n        return this._def.returns;\r\n    }\r\n    args(...items) {\r\n        return new ZodFunction({\r\n            ...this._def,\r\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\r\n        });\r\n    }\r\n    returns(returnType) {\r\n        return new ZodFunction({\r\n            ...this._def,\r\n            returns: returnType,\r\n        });\r\n    }\r\n    implement(func) {\r\n        const validatedFunc = this.parse(func);\r\n        return validatedFunc;\r\n    }\r\n    strictImplement(func) {\r\n        const validatedFunc = this.parse(func);\r\n        return validatedFunc;\r\n    }\r\n    static create(args, returns, params) {\r\n        return new ZodFunction({\r\n            args: (args\r\n                ? args\r\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\r\n            returns: returns || ZodUnknown.create(),\r\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\r\n            ...processCreateParams(params),\r\n        });\r\n    }\r\n}\r\nclass ZodLazy extends ZodType {\r\n    get schema() {\r\n        return this._def.getter();\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const lazySchema = this._def.getter();\r\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\r\n    }\r\n}\r\nZodLazy.create = (getter, params) => {\r\n    return new ZodLazy({\r\n        getter: getter,\r\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodLiteral extends ZodType {\r\n    _parse(input) {\r\n        if (input.data !== this._def.value) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_literal,\r\n                expected: this._def.value,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return { status: \"valid\", value: input.data };\r\n    }\r\n    get value() {\r\n        return this._def.value;\r\n    }\r\n}\r\nZodLiteral.create = (value, params) => {\r\n    return new ZodLiteral({\r\n        value: value,\r\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction createZodEnum(values, params) {\r\n    return new ZodEnum({\r\n        values,\r\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\r\n        ...processCreateParams(params),\r\n    });\r\n}\r\nclass ZodEnum extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        _ZodEnum_cache.set(this, void 0);\r\n    }\r\n    _parse(input) {\r\n        if (typeof input.data !== \"string\") {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            const expectedValues = this._def.values;\r\n            addIssueToContext(ctx, {\r\n                expected: util.joinValues(expectedValues),\r\n                received: ctx.parsedType,\r\n                code: ZodIssueCode.invalid_type,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\r\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            const expectedValues = this._def.values;\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_enum_value,\r\n                options: expectedValues,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n    get options() {\r\n        return this._def.values;\r\n    }\r\n    get enum() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    get Values() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    get Enum() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    extract(values, newDef = this._def) {\r\n        return ZodEnum.create(values, {\r\n            ...this._def,\r\n            ...newDef,\r\n        });\r\n    }\r\n    exclude(values, newDef = this._def) {\r\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\r\n            ...this._def,\r\n            ...newDef,\r\n        });\r\n    }\r\n}\r\n_ZodEnum_cache = new WeakMap();\r\nZodEnum.create = createZodEnum;\r\nclass ZodNativeEnum extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        _ZodNativeEnum_cache.set(this, void 0);\r\n    }\r\n    _parse(input) {\r\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\r\n        const ctx = this._getOrReturnCtx(input);\r\n        if (ctx.parsedType !== ZodParsedType.string &&\r\n            ctx.parsedType !== ZodParsedType.number) {\r\n            const expectedValues = util.objectValues(nativeEnumValues);\r\n            addIssueToContext(ctx, {\r\n                expected: util.joinValues(expectedValues),\r\n                received: ctx.parsedType,\r\n                code: ZodIssueCode.invalid_type,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\r\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\r\n            const expectedValues = util.objectValues(nativeEnumValues);\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_enum_value,\r\n                options: expectedValues,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n    get enum() {\r\n        return this._def.values;\r\n    }\r\n}\r\n_ZodNativeEnum_cache = new WeakMap();\r\nZodNativeEnum.create = (values, params) => {\r\n    return new ZodNativeEnum({\r\n        values: values,\r\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodPromise extends ZodType {\r\n    unwrap() {\r\n        return this._def.type;\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.promise &&\r\n            ctx.common.async === false) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.promise,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const promisified = ctx.parsedType === ZodParsedType.promise\r\n            ? ctx.data\r\n            : Promise.resolve(ctx.data);\r\n        return OK(promisified.then((data) => {\r\n            return this._def.type.parseAsync(data, {\r\n                path: ctx.path,\r\n                errorMap: ctx.common.contextualErrorMap,\r\n            });\r\n        }));\r\n    }\r\n}\r\nZodPromise.create = (schema, params) => {\r\n    return new ZodPromise({\r\n        type: schema,\r\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodEffects extends ZodType {\r\n    innerType() {\r\n        return this._def.schema;\r\n    }\r\n    sourceType() {\r\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\r\n            ? this._def.schema.sourceType()\r\n            : this._def.schema;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const effect = this._def.effect || null;\r\n        const checkCtx = {\r\n            addIssue: (arg) => {\r\n                addIssueToContext(ctx, arg);\r\n                if (arg.fatal) {\r\n                    status.abort();\r\n                }\r\n                else {\r\n                    status.dirty();\r\n                }\r\n            },\r\n            get path() {\r\n                return ctx.path;\r\n            },\r\n        };\r\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\r\n        if (effect.type === \"preprocess\") {\r\n            const processed = effect.transform(ctx.data, checkCtx);\r\n            if (ctx.common.async) {\r\n                return Promise.resolve(processed).then(async (processed) => {\r\n                    if (status.value === \"aborted\")\r\n                        return INVALID;\r\n                    const result = await this._def.schema._parseAsync({\r\n                        data: processed,\r\n                        path: ctx.path,\r\n                        parent: ctx,\r\n                    });\r\n                    if (result.status === \"aborted\")\r\n                        return INVALID;\r\n                    if (result.status === \"dirty\")\r\n                        return DIRTY(result.value);\r\n                    if (status.value === \"dirty\")\r\n                        return DIRTY(result.value);\r\n                    return result;\r\n                });\r\n            }\r\n            else {\r\n                if (status.value === \"aborted\")\r\n                    return INVALID;\r\n                const result = this._def.schema._parseSync({\r\n                    data: processed,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (result.status === \"aborted\")\r\n                    return INVALID;\r\n                if (result.status === \"dirty\")\r\n                    return DIRTY(result.value);\r\n                if (status.value === \"dirty\")\r\n                    return DIRTY(result.value);\r\n                return result;\r\n            }\r\n        }\r\n        if (effect.type === \"refinement\") {\r\n            const executeRefinement = (acc) => {\r\n                const result = effect.refinement(acc, checkCtx);\r\n                if (ctx.common.async) {\r\n                    return Promise.resolve(result);\r\n                }\r\n                if (result instanceof Promise) {\r\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\r\n                }\r\n                return acc;\r\n            };\r\n            if (ctx.common.async === false) {\r\n                const inner = this._def.schema._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (inner.status === \"aborted\")\r\n                    return INVALID;\r\n                if (inner.status === \"dirty\")\r\n                    status.dirty();\r\n                // return value is ignored\r\n                executeRefinement(inner.value);\r\n                return { status: status.value, value: inner.value };\r\n            }\r\n            else {\r\n                return this._def.schema\r\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\r\n                    .then((inner) => {\r\n                    if (inner.status === \"aborted\")\r\n                        return INVALID;\r\n                    if (inner.status === \"dirty\")\r\n                        status.dirty();\r\n                    return executeRefinement(inner.value).then(() => {\r\n                        return { status: status.value, value: inner.value };\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        if (effect.type === \"transform\") {\r\n            if (ctx.common.async === false) {\r\n                const base = this._def.schema._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (!isValid(base))\r\n                    return base;\r\n                const result = effect.transform(base.value, checkCtx);\r\n                if (result instanceof Promise) {\r\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\r\n                }\r\n                return { status: status.value, value: result };\r\n            }\r\n            else {\r\n                return this._def.schema\r\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\r\n                    .then((base) => {\r\n                    if (!isValid(base))\r\n                        return base;\r\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\r\n                });\r\n            }\r\n        }\r\n        util.assertNever(effect);\r\n    }\r\n}\r\nZodEffects.create = (schema, effect, params) => {\r\n    return new ZodEffects({\r\n        schema,\r\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n        effect,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\r\n    return new ZodEffects({\r\n        schema,\r\n        effect: { type: \"preprocess\", transform: preprocess },\r\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodOptional extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType === ZodParsedType.undefined) {\r\n            return OK(undefined);\r\n        }\r\n        return this._def.innerType._parse(input);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodOptional.create = (type, params) => {\r\n    return new ZodOptional({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNullable extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType === ZodParsedType.null) {\r\n            return OK(null);\r\n        }\r\n        return this._def.innerType._parse(input);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodNullable.create = (type, params) => {\r\n    return new ZodNullable({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodDefault extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        let data = ctx.data;\r\n        if (ctx.parsedType === ZodParsedType.undefined) {\r\n            data = this._def.defaultValue();\r\n        }\r\n        return this._def.innerType._parse({\r\n            data,\r\n            path: ctx.path,\r\n            parent: ctx,\r\n        });\r\n    }\r\n    removeDefault() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodDefault.create = (type, params) => {\r\n    return new ZodDefault({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\r\n        defaultValue: typeof params.default === \"function\"\r\n            ? params.default\r\n            : () => params.default,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodCatch extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        // newCtx is used to not collect issues from inner types in ctx\r\n        const newCtx = {\r\n            ...ctx,\r\n            common: {\r\n                ...ctx.common,\r\n                issues: [],\r\n            },\r\n        };\r\n        const result = this._def.innerType._parse({\r\n            data: newCtx.data,\r\n            path: newCtx.path,\r\n            parent: {\r\n                ...newCtx,\r\n            },\r\n        });\r\n        if (isAsync(result)) {\r\n            return result.then((result) => {\r\n                return {\r\n                    status: \"valid\",\r\n                    value: result.status === \"valid\"\r\n                        ? result.value\r\n                        : this._def.catchValue({\r\n                            get error() {\r\n                                return new ZodError(newCtx.common.issues);\r\n                            },\r\n                            input: newCtx.data,\r\n                        }),\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            return {\r\n                status: \"valid\",\r\n                value: result.status === \"valid\"\r\n                    ? result.value\r\n                    : this._def.catchValue({\r\n                        get error() {\r\n                            return new ZodError(newCtx.common.issues);\r\n                        },\r\n                        input: newCtx.data,\r\n                    }),\r\n            };\r\n        }\r\n    }\r\n    removeCatch() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodCatch.create = (type, params) => {\r\n    return new ZodCatch({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\r\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNaN extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.nan) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.nan,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return { status: \"valid\", value: input.data };\r\n    }\r\n}\r\nZodNaN.create = (params) => {\r\n    return new ZodNaN({\r\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nconst BRAND = Symbol(\"zod_brand\");\r\nclass ZodBranded extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const data = ctx.data;\r\n        return this._def.type._parse({\r\n            data,\r\n            path: ctx.path,\r\n            parent: ctx,\r\n        });\r\n    }\r\n    unwrap() {\r\n        return this._def.type;\r\n    }\r\n}\r\nclass ZodPipeline extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.common.async) {\r\n            const handleAsync = async () => {\r\n                const inResult = await this._def.in._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (inResult.status === \"aborted\")\r\n                    return INVALID;\r\n                if (inResult.status === \"dirty\") {\r\n                    status.dirty();\r\n                    return DIRTY(inResult.value);\r\n                }\r\n                else {\r\n                    return this._def.out._parseAsync({\r\n                        data: inResult.value,\r\n                        path: ctx.path,\r\n                        parent: ctx,\r\n                    });\r\n                }\r\n            };\r\n            return handleAsync();\r\n        }\r\n        else {\r\n            const inResult = this._def.in._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n            if (inResult.status === \"aborted\")\r\n                return INVALID;\r\n            if (inResult.status === \"dirty\") {\r\n                status.dirty();\r\n                return {\r\n                    status: \"dirty\",\r\n                    value: inResult.value,\r\n                };\r\n            }\r\n            else {\r\n                return this._def.out._parseSync({\r\n                    data: inResult.value,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n            }\r\n        }\r\n    }\r\n    static create(a, b) {\r\n        return new ZodPipeline({\r\n            in: a,\r\n            out: b,\r\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\r\n        });\r\n    }\r\n}\r\nclass ZodReadonly extends ZodType {\r\n    _parse(input) {\r\n        const result = this._def.innerType._parse(input);\r\n        const freeze = (data) => {\r\n            if (isValid(data)) {\r\n                data.value = Object.freeze(data.value);\r\n            }\r\n            return data;\r\n        };\r\n        return isAsync(result)\r\n            ? result.then((data) => freeze(data))\r\n            : freeze(result);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodReadonly.create = (type, params) => {\r\n    return new ZodReadonly({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction custom(check, params = {}, \r\n/**\r\n * @deprecated\r\n *\r\n * Pass `fatal` into the params object instead:\r\n *\r\n * ```ts\r\n * z.string().custom((val) => val.length > 5, { fatal: false })\r\n * ```\r\n *\r\n */\r\nfatal) {\r\n    if (check)\r\n        return ZodAny.create().superRefine((data, ctx) => {\r\n            var _a, _b;\r\n            if (!check(data)) {\r\n                const p = typeof params === \"function\"\r\n                    ? params(data)\r\n                    : typeof params === \"string\"\r\n                        ? { message: params }\r\n                        : params;\r\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\r\n                const p2 = typeof p === \"string\" ? { message: p } : p;\r\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\r\n            }\r\n        });\r\n    return ZodAny.create();\r\n}\r\nconst late = {\r\n    object: ZodObject.lazycreate,\r\n};\r\nvar ZodFirstPartyTypeKind;\r\n(function (ZodFirstPartyTypeKind) {\r\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\r\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\r\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\r\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\r\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\r\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\r\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\r\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\r\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\r\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\r\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\r\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\r\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\r\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\r\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\r\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\r\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\r\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\r\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\r\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\r\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\r\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\r\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\r\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\r\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\r\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\r\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\r\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\r\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\r\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\r\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\r\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\r\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\r\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\r\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\r\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\r\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\r\nconst instanceOfType = (\r\n// const instanceOfType = <T extends new (...args: any[]) => any>(\r\ncls, params = {\r\n    message: `Input not instance of ${cls.name}`,\r\n}) => custom((data) => data instanceof cls, params);\r\nconst stringType = ZodString.create;\r\nconst numberType = ZodNumber.create;\r\nconst nanType = ZodNaN.create;\r\nconst bigIntType = ZodBigInt.create;\r\nconst booleanType = ZodBoolean.create;\r\nconst dateType = ZodDate.create;\r\nconst symbolType = ZodSymbol.create;\r\nconst undefinedType = ZodUndefined.create;\r\nconst nullType = ZodNull.create;\r\nconst anyType = ZodAny.create;\r\nconst unknownType = ZodUnknown.create;\r\nconst neverType = ZodNever.create;\r\nconst voidType = ZodVoid.create;\r\nconst arrayType = ZodArray.create;\r\nconst objectType = ZodObject.create;\r\nconst strictObjectType = ZodObject.strictCreate;\r\nconst unionType = ZodUnion.create;\r\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\r\nconst intersectionType = ZodIntersection.create;\r\nconst tupleType = ZodTuple.create;\r\nconst recordType = ZodRecord.create;\r\nconst mapType = ZodMap.create;\r\nconst setType = ZodSet.create;\r\nconst functionType = ZodFunction.create;\r\nconst lazyType = ZodLazy.create;\r\nconst literalType = ZodLiteral.create;\r\nconst enumType = ZodEnum.create;\r\nconst nativeEnumType = ZodNativeEnum.create;\r\nconst promiseType = ZodPromise.create;\r\nconst effectsType = ZodEffects.create;\r\nconst optionalType = ZodOptional.create;\r\nconst nullableType = ZodNullable.create;\r\nconst preprocessType = ZodEffects.createWithPreprocess;\r\nconst pipelineType = ZodPipeline.create;\r\nconst ostring = () => stringType().optional();\r\nconst onumber = () => numberType().optional();\r\nconst oboolean = () => booleanType().optional();\r\nconst coerce = {\r\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\r\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\r\n    boolean: ((arg) => ZodBoolean.create({\r\n        ...arg,\r\n        coerce: true,\r\n    })),\r\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\r\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\r\n};\r\nconst NEVER = INVALID;\r\n\r\nvar z = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    defaultErrorMap: errorMap,\r\n    setErrorMap: setErrorMap,\r\n    getErrorMap: getErrorMap,\r\n    makeIssue: makeIssue,\r\n    EMPTY_PATH: EMPTY_PATH,\r\n    addIssueToContext: addIssueToContext,\r\n    ParseStatus: ParseStatus,\r\n    INVALID: INVALID,\r\n    DIRTY: DIRTY,\r\n    OK: OK,\r\n    isAborted: isAborted,\r\n    isDirty: isDirty,\r\n    isValid: isValid,\r\n    isAsync: isAsync,\r\n    get util () { return util; },\r\n    get objectUtil () { return objectUtil; },\r\n    ZodParsedType: ZodParsedType,\r\n    getParsedType: getParsedType,\r\n    ZodType: ZodType,\r\n    datetimeRegex: datetimeRegex,\r\n    ZodString: ZodString,\r\n    ZodNumber: ZodNumber,\r\n    ZodBigInt: ZodBigInt,\r\n    ZodBoolean: ZodBoolean,\r\n    ZodDate: ZodDate,\r\n    ZodSymbol: ZodSymbol,\r\n    ZodUndefined: ZodUndefined,\r\n    ZodNull: ZodNull,\r\n    ZodAny: ZodAny,\r\n    ZodUnknown: ZodUnknown,\r\n    ZodNever: ZodNever,\r\n    ZodVoid: ZodVoid,\r\n    ZodArray: ZodArray,\r\n    ZodObject: ZodObject,\r\n    ZodUnion: ZodUnion,\r\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\r\n    ZodIntersection: ZodIntersection,\r\n    ZodTuple: ZodTuple,\r\n    ZodRecord: ZodRecord,\r\n    ZodMap: ZodMap,\r\n    ZodSet: ZodSet,\r\n    ZodFunction: ZodFunction,\r\n    ZodLazy: ZodLazy,\r\n    ZodLiteral: ZodLiteral,\r\n    ZodEnum: ZodEnum,\r\n    ZodNativeEnum: ZodNativeEnum,\r\n    ZodPromise: ZodPromise,\r\n    ZodEffects: ZodEffects,\r\n    ZodTransformer: ZodEffects,\r\n    ZodOptional: ZodOptional,\r\n    ZodNullable: ZodNullable,\r\n    ZodDefault: ZodDefault,\r\n    ZodCatch: ZodCatch,\r\n    ZodNaN: ZodNaN,\r\n    BRAND: BRAND,\r\n    ZodBranded: ZodBranded,\r\n    ZodPipeline: ZodPipeline,\r\n    ZodReadonly: ZodReadonly,\r\n    custom: custom,\r\n    Schema: ZodType,\r\n    ZodSchema: ZodType,\r\n    late: late,\r\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\r\n    coerce: coerce,\r\n    any: anyType,\r\n    array: arrayType,\r\n    bigint: bigIntType,\r\n    boolean: booleanType,\r\n    date: dateType,\r\n    discriminatedUnion: discriminatedUnionType,\r\n    effect: effectsType,\r\n    'enum': enumType,\r\n    'function': functionType,\r\n    'instanceof': instanceOfType,\r\n    intersection: intersectionType,\r\n    lazy: lazyType,\r\n    literal: literalType,\r\n    map: mapType,\r\n    nan: nanType,\r\n    nativeEnum: nativeEnumType,\r\n    never: neverType,\r\n    'null': nullType,\r\n    nullable: nullableType,\r\n    number: numberType,\r\n    object: objectType,\r\n    oboolean: oboolean,\r\n    onumber: onumber,\r\n    optional: optionalType,\r\n    ostring: ostring,\r\n    pipeline: pipelineType,\r\n    preprocess: preprocessType,\r\n    promise: promiseType,\r\n    record: recordType,\r\n    set: setType,\r\n    strictObject: strictObjectType,\r\n    string: stringType,\r\n    symbol: symbolType,\r\n    transformer: effectsType,\r\n    tuple: tupleType,\r\n    'undefined': undefinedType,\r\n    union: unionType,\r\n    unknown: unknownType,\r\n    'void': voidType,\r\n    NEVER: NEVER,\r\n    ZodIssueCode: ZodIssueCode,\r\n    quotelessJson: quotelessJson,\r\n    ZodError: ZodError\r\n});\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCLHNCQUFzQixjQUFjO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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YTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUM0ckQiLCJzb3VyY2VzIjpbIkM6XFxsYXJhZ29uXFx3d3dcXG5leHQtYmlnbWVhbFxcbm9kZV9tb2R1bGVzXFx6b2RcXGxpYlxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsO1xyXG4oZnVuY3Rpb24gKHV0aWwpIHtcclxuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XHJcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cclxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcclxuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XHJcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XHJcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcclxuICAgIH07XHJcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcclxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXHJcbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxyXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9O1xyXG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cclxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcclxuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlcclxuICAgICAgICAgICAgLm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKVxyXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcclxuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XHJcbnZhciBvYmplY3RVdGlsO1xyXG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcclxuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLmZpcnN0LFxyXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xyXG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXHJcbiAgICBcInN0cmluZ1wiLFxyXG4gICAgXCJuYW5cIixcclxuICAgIFwibnVtYmVyXCIsXHJcbiAgICBcImludGVnZXJcIixcclxuICAgIFwiZmxvYXRcIixcclxuICAgIFwiYm9vbGVhblwiLFxyXG4gICAgXCJkYXRlXCIsXHJcbiAgICBcImJpZ2ludFwiLFxyXG4gICAgXCJzeW1ib2xcIixcclxuICAgIFwiZnVuY3Rpb25cIixcclxuICAgIFwidW5kZWZpbmVkXCIsXHJcbiAgICBcIm51bGxcIixcclxuICAgIFwiYXJyYXlcIixcclxuICAgIFwib2JqZWN0XCIsXHJcbiAgICBcInVua25vd25cIixcclxuICAgIFwicHJvbWlzZVwiLFxyXG4gICAgXCJ2b2lkXCIsXHJcbiAgICBcIm5ldmVyXCIsXHJcbiAgICBcIm1hcFwiLFxyXG4gICAgXCJzZXRcIixcclxuXSk7XHJcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xyXG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xyXG4gICAgc3dpdGNoICh0KSB7XHJcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XHJcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xyXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XHJcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xyXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xyXG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IFpvZElzc3VlQ29kZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xyXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcclxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXHJcbiAgICBcImN1c3RvbVwiLFxyXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXHJcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxyXG4gICAgXCJpbnZhbGlkX2VudW1fdmFsdWVcIixcclxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcclxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcclxuICAgIFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiLFxyXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcclxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcclxuICAgIFwidG9vX3NtYWxsXCIsXHJcbiAgICBcInRvb19iaWdcIixcclxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcclxuICAgIFwibm90X211bHRpcGxlX29mXCIsXHJcbiAgICBcIm5vdF9maW5pdGVcIixcclxuXSk7XHJcbmNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XHJcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcclxuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XHJcbn07XHJcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XHJcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxyXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xyXG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVycm9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XHJcbiAgICB9XHJcbiAgICBmb3JtYXQoX21hcHBlcikge1xyXG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcclxuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RFcnJvcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHt2YWx1ZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xyXG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xyXG4gICAgfVxyXG59XHJcblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn07XHJcblxyXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xyXG4gICAgbGV0IG1lc3NhZ2U7XHJcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XHJcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XHJcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxyXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XHJcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcclxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfZmluaXRlOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xyXG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcclxufTtcclxuXHJcbmxldCBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XHJcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xyXG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcclxufVxyXG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcclxuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xyXG59XHJcblxyXG5jb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XHJcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcclxuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcclxuICAgICAgICAuLi5pc3N1ZURhdGEsXHJcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXHJcbiAgICB9O1xyXG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5pc3N1ZURhdGEsXHJcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XHJcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXHJcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxyXG4gICAgICAgIC5zbGljZSgpXHJcbiAgICAgICAgLnJldmVyc2UoKTtcclxuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmlzc3VlRGF0YSxcclxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcclxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCBFTVBUWV9QQVRIID0gW107XHJcbmZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XHJcbiAgICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XHJcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XHJcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXHJcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgZXJyb3JNYXBzOiBbXHJcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxyXG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXHJcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLFxyXG4gICAgICAgICAgICBvdmVycmlkZU1hcCA9PT0gZXJyb3JNYXAgPyB1bmRlZmluZWQgOiBlcnJvck1hcCwgLy8gdGhlbiBnbG9iYWwgZGVmYXVsdCBtYXBcclxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcclxuICAgIH0pO1xyXG4gICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaChpc3N1ZSk7XHJcbn1cclxuY2xhc3MgUGFyc2VTdGF0dXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcclxuICAgIH1cclxuICAgIGRpcnR5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XHJcbiAgICB9XHJcbiAgICBhYm9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xyXG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xyXG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XHJcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XHJcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcclxuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmXHJcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcclxuICAgIH1cclxufVxyXG5jb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxyXG59KTtcclxuY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcclxuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcclxuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcclxuY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xyXG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XHJcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcclxuXHJcbnZhciBlcnJvclV0aWw7XHJcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XHJcbiAgICBlcnJvclV0aWwuZXJyVG9PYmogPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2UgfSA6IG1lc3NhZ2UgfHwge307XHJcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLm1lc3NhZ2U7XHJcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcclxuXHJcbnZhciBfWm9kRW51bV9jYWNoZSwgX1pvZE5hdGl2ZUVudW1fY2FjaGU7XHJcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcclxuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhdGgoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XHJcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XHJcbiAgICBpZiAoIXBhcmFtcylcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xyXG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xyXG4gICAgfVxyXG4gICAgaWYgKGVycm9yTWFwKVxyXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcclxuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XHJcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2EgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiByZXF1aXJlZF9lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3R4LmRlZmF1bHRFcnJvciB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcclxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2IgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBpbnZhbGlkX3R5cGVfZXJyb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xyXG59XHJcbmNsYXNzIFpvZFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoZGVmKSB7XHJcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXHJcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xyXG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcclxuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xyXG4gICAgfVxyXG4gICAgX2dldFR5cGUoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcclxuICAgIH1cclxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XHJcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xyXG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXHJcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXHJcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXHJcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXHJcbiAgICAgICAgICAgIGN0eDoge1xyXG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcclxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXHJcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xyXG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcclxuICAgIH1cclxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY3R4ID0ge1xyXG4gICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXHJcbiAgICAgICAgICAgICAgICBhc3luYzogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFzeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxyXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcclxuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcclxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBjdHggPSB7XHJcbiAgICAgICAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXHJcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoaXNBc3luYyhtYXliZUFzeW5jUmVzdWx0KVxyXG4gICAgICAgICAgICA/IG1heWJlQXN5bmNSZXN1bHRcclxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgZ2V0SXNzdWVQcm9wZXJ0aWVzID0gKHZhbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVjayh2YWwpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxyXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcclxuICAgICAgICAgICAgICAgICAgICA6IHJlZmluZW1lbnREYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXHJcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgb3B0aW9uYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgbnVsbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgbnVsbGlzaCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XHJcbiAgICB9XHJcbiAgICBhcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICBwcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgb3Iob3B0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcclxuICAgIH1cclxuICAgIGFuZChpbmNvbWluZykge1xyXG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcclxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXHJcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQoZGVmKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXHJcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBicmFuZCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhdGNoKGRlZikge1xyXG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXHJcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcclxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwaXBlKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJlYWRvbmx5KCkge1xyXG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICBpc09wdGlvbmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XHJcbiAgICB9XHJcbiAgICBpc051bGxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xyXG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcclxuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC87XHJcbi8vIGNvbnN0IHV1aWRSZWdleCA9XHJcbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcclxuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XHJcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcclxuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XHJcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcclxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXHJcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XHJcbi8vb2xkIGVtYWlsIHJlZ2V4XHJcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuLy8gY29uc3QgZW1haWxSZWdleCA9XHJcbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xyXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cclxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xyXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cclxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xyXG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcclxuLy8gY29uc3QgZW1haWxSZWdleCA9XHJcbi8vICAgL15bYS16MC05LiEjJCUm4oCZKisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcclxuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXHJcbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcclxubGV0IGVtb2ppUmVnZXg7XHJcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcclxuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XHJcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxyXG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcclxuLy8gc2ltcGxlXHJcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XHJcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXHJcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XHJcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cclxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XHJcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XHJcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XHJcbiAgICAvLyBsZXQgcmVnZXggPSBgXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn1gO1xyXG4gICAgbGV0IHJlZ2V4ID0gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGRgO1xyXG4gICAgaWYgKGFyZ3MucHJlY2lzaW9uKSB7XHJcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH0oXFxcXC5cXFxcZCspP2A7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVnZXg7XHJcbn1cclxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9JGApO1xyXG59XHJcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxyXG5mdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcclxuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcclxuICAgIGNvbnN0IG9wdHMgPSBbXTtcclxuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XHJcbiAgICBpZiAoYXJncy5vZmZzZXQpXHJcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcclxuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGNoZWNrLnJlZ2V4LnRlc3QoaW5wdXQuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5pbmNsdWRlcyhjaGVjay52YWx1ZSwgY2hlY2sucG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogY2hlY2sudmFsdWUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVuZHNXaXRoXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRldGltZVJlZ2V4KGNoZWNrKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRlUmVnZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSB0aW1lUmVnZXgoY2hlY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbixcclxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZW1haWwobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgdXJsKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICBlbW9qaShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICB1dWlkKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm5hbm9pZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICBjdWlkKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgY3VpZDIobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgdWxpZChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIGJhc2U2NChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgaXAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xyXG4gICAgfVxyXG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcclxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXHJcbiAgICAgICAgICAgIG9mZnNldDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGxvY2FsOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGF0ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XHJcbiAgICB9XHJcbiAgICB0aW1lKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxyXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxyXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXHJcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXHJcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcclxuICAgICAgICAgICAgdmFsdWU6IGxlbixcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugei5zdHJpbmcoKS5taW4oMSkgaW5zdGVhZC5cclxuICAgICAqIEBzZWUge0BsaW5rIFpvZFN0cmluZy5taW59XHJcbiAgICAgKi9cclxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIHRyaW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0b0xvd2VyQ2FzZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0b1VwcGVyQ2FzZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEYXRldGltZSgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcclxuICAgIH1cclxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbWFpbCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzVVJMKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRW1vamkoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcclxuICAgIH1cclxuICAgIGdldCBpc1VVSUQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzTkFOT0lEKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ1VJRCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNDVUlEMigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzVUxJRCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNJUCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQmFzZTY0KCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcclxuICAgICAgICBsZXQgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgIH1cclxuICAgIGdldCBtYXhMZW5ndGgoKSB7XHJcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9XHJcbn1cclxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcclxuICAgICAgICBjaGVja3M6IFtdLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxyXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxyXG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XHJcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xyXG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xyXG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xyXG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcclxuICAgIGNvbnN0IHN0ZXBJbnQgPSBwYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcclxuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xyXG59XHJcbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xyXG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcclxuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xyXG4gICAgfVxyXG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogW1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJpbnRcIixcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtaW5cIixcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZpbml0ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2FmZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtaW5cIixcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pblZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzSW50KCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcclxuICAgICAgICAgICAgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRmluaXRlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fFxyXG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJpbnRcIiB8fFxyXG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XHJcbiAgICB9XHJcbn1cclxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcclxuICAgICAgICBjaGVja3M6IFtdLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxyXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcclxuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcclxuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xyXG4gICAgfVxyXG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogW1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pblZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG59XHJcblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XHJcbiAgICAgICAgY2hlY2tzOiBbXSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcclxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxyXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9hZGRDaGVjayhjaGVjaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWluRGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4RGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XHJcbiAgICB9XHJcbn1cclxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xyXG4gICAgICAgIGNoZWNrczogW10sXHJcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG59XHJcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cclxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG59XHJcblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gcmVxdWlyZWRcclxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcclxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgfVxyXG59XHJcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XHJcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcclxuICAgIH1cclxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xyXG4gICAgICAgIHR5cGU6IHNjaGVtYSxcclxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXHJcbiAgICAgICAgbWF4TGVuZ3RoOiBudWxsLFxyXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xyXG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcclxuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXHJcbiAgICAgICAgICAgIHR5cGU6IGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS5lbGVtZW50KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cclxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcclxuICAgICAgICAvLyBleHRlbmQ8XHJcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcclxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XHJcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cclxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cclxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcclxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxyXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XHJcbiAgICAgICAgLy8gICB9PixcclxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcclxuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXHJcbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cclxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxyXG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cclxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xyXG4gICAgICAgIC8vICAgfT5cclxuICAgICAgICAvLyA+KFxyXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cclxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XHJcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxyXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXHJcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcclxuICAgICAgICAvLyAgIE5ld091dHB1dCxcclxuICAgICAgICAvLyAgIE5ld0lucHV0XHJcbiAgICAgICAgLy8gPiB7XHJcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XHJcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgICAgIC8vICAgICB9KSxcclxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXHJcbiAgICAgICAgICogICovXHJcbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q2FjaGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcclxuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcclxuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcGVLZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcclxuICAgICAgICAgICAgcGFpcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxyXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XHJcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgc2hhcGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xyXG4gICAgfVxyXG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcclxuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxyXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge30pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RyaXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwYXNzdGhyb3VnaCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cclxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XHJcbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXHJcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cclxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxyXG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxyXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxyXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXHJcbiAgICAvLyAgID4gPT4ge1xyXG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgIC8vICAgICAgIC4uLmRlZixcclxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xyXG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcclxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgLy8gICAgICAgfSksXHJcbiAgICAvLyAgICAgfSkgYXMgYW55O1xyXG4gICAgLy8gICB9O1xyXG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxyXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXHJcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcclxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxyXG4gICAgICovXHJcbiAgICBtZXJnZShtZXJnaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXHJcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBtZXJnZTxcclxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXHJcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXHJcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcclxuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXHJcbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cclxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxyXG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cclxuICAgIC8vICAgICAgIDogbmV2ZXI7XHJcbiAgICAvLyAgIH0sXHJcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xyXG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxyXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cclxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XHJcbiAgICAvLyAgICAgICA/IElucHV0W2tdXHJcbiAgICAvLyAgICAgICA6IG5ldmVyO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyA+KFxyXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xyXG4gICAgLy8gKTogWm9kT2JqZWN0PFxyXG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXHJcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxyXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcclxuICAgIC8vICAgTmV3T3V0cHV0LFxyXG4gICAgLy8gICBOZXdJbnB1dFxyXG4gICAgLy8gPiB7XHJcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcclxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxyXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxyXG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxyXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgLy8gICB9KSBhcyBhbnk7XHJcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICAvLyB9XHJcbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcclxuICAgIH1cclxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcclxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcclxuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XHJcbiAgICAvLyBab2RPYmplY3Q8XHJcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcclxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXHJcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXHJcbiAgICAvLyA+IHtcclxuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxyXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxyXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXHJcbiAgICAvLyAgIC8vICk7XHJcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcclxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxyXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxyXG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxyXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgLy8gICB9KSBhcyBhbnk7XHJcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICAvLyB9XHJcbiAgICBjYXRjaGFsbChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwaWNrKG1hc2spIHtcclxuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xyXG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb21pdChtYXNrKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcclxuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgZGVlcFBhcnRpYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcGFydGlhbChtYXNrKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcclxuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXF1aXJlZChtYXNrKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcclxuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGtleW9mKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XHJcbiAgICB9XHJcbn1cclxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxyXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXHJcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXHJcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXHJcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcclxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXHJcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxyXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcclxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xyXG4gICAgfVxyXG59XHJcblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcclxuICAgICAgICBvcHRpb25zOiB0eXBlcyxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcclxuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xyXG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXHJcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xyXG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xyXG4gICAgICAgIHJldHVybiBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xyXG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcclxuICAgICAgICBpZiAoIW9wdGlvbikge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogW2Rpc2NyaW1pbmF0b3JdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcclxuICAgIH1cclxuICAgIGdldCBvcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcclxuICAgIH1cclxuICAgIGdldCBvcHRpb25zTWFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cclxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcclxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cclxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcclxuICAgICAqIEBwYXJhbSBwYXJhbXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcclxuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gdHJ5IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcclxuICAgICAgICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcclxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXHJcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IsXHJcbiAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XHJcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XHJcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XHJcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWxcclxuICAgICAgICAgICAgLm9iamVjdEtleXMoYSlcclxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcclxuICAgICAgICBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXHJcbiAgICAgICAgK2EgPT09ICtiKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiByaWdodCxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xyXG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxyXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XHJcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBpdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xyXG4gICAgfVxyXG4gICAgcmVzdChyZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgcmVzdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xyXG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXHJcbiAgICAgICAgcmVzdDogbnVsbCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQga2V5U2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XHJcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xyXG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcclxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xyXG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcclxuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxyXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXHJcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcclxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xyXG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQga2V5U2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XHJcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XHJcbiAgICAgICAgdmFsdWVUeXBlLFxyXG4gICAgICAgIGtleVR5cGUsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xyXG4gICAgICAgIHZhbHVlVHlwZSxcclxuICAgICAgICBtaW5TaXplOiBudWxsLFxyXG4gICAgICAgIG1heFNpemU6IG51bGwsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yTWFwKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcclxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHJldHVybnMsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcclxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXHJcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XHJcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXHJcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMoYXJncywgcGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcclxuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XHJcbiAgICB9XHJcbiAgICBhcmdzKC4uLml0ZW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGltcGxlbWVudChmdW5jKSB7XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XHJcbiAgICB9XHJcbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShhcmdzLCByZXR1cm5zLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcclxuICAgICAgICAgICAgYXJnczogKGFyZ3NcclxuICAgICAgICAgICAgICAgID8gYXJnc1xyXG4gICAgICAgICAgICAgICAgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxyXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQgc2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xyXG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XHJcbiAgICB9XHJcbn1cclxuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XHJcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAoaW5wdXQuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xyXG4gICAgfVxyXG59XHJcblpvZExpdGVyYWwuY3JlYXRlID0gKHZhbHVlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcclxuICAgICAgICB2YWx1ZXMsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59XHJcbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpKSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcclxuICAgIH1cclxuICAgIGdldCBlbnVtKCkge1xyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgVmFsdWVzKCkge1xyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgRW51bSgpIHtcclxuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xyXG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xyXG4gICAgfVxyXG4gICAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xyXG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICAuLi5uZXdEZWYsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIC4uLm5ld0RlZixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5fWm9kRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcclxuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBfWm9kTmF0aXZlRW51bV9jYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcclxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxyXG4gICAgICAgICAgICBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBcImZcIikpIHtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxuICAgIGdldCBlbnVtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xyXG4gICAgfVxyXG59XHJcbl9ab2ROYXRpdmVFbnVtX2NhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XHJcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcclxuICAgICAgICAgICAgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2VcclxuICAgICAgICAgICAgPyBjdHguZGF0YVxyXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxufVxyXG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcclxuICAgICAgICB0eXBlOiBzY2hlbWEsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBpbm5lclR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICBzb3VyY2VUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXHJcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcclxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xyXG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xyXG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcclxuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoYmFzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoeyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICBzY2hlbWEsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxyXG4gICAgICAgIGVmZmVjdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICBzY2hlbWEsXHJcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG59XHJcblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xyXG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG59XHJcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xyXG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcclxuICAgIH1cclxufVxyXG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XHJcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcclxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcclxuICAgICAgICAgICAgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxyXG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcclxuICAgICAgICAgICAgLi4uY3R4LFxyXG4gICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xyXG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcclxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDoge1xyXG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVDYXRjaCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcclxuICAgIH1cclxufVxyXG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcclxuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcclxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxufVxyXG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcclxuY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZFBpcGVsaW5lIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBc3luYygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kUGlwZWxpbmUoe1xyXG4gICAgICAgICAgICBpbjogYSxcclxuICAgICAgICAgICAgb3V0OiBiLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KVxyXG4gICAgICAgICAgICA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpXHJcbiAgICAgICAgICAgIDogZnJlZXplKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XHJcbiAgICB9XHJcbn1cclxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XHJcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGN1c3RvbShjaGVjaywgcGFyYW1zID0ge30sIFxyXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICpcclxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcclxuICpcclxuICogYGBgdHNcclxuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuZmF0YWwpIHtcclxuICAgIGlmIChjaGVjaylcclxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zKGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBtZXNzYWdlOiBwYXJhbXMgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IChfYiA9IChfYSA9IHAuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcclxuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnAyLCBmYXRhbDogX2ZhdGFsIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xyXG59XHJcbmNvbnN0IGxhdGUgPSB7XHJcbiAgICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlLFxyXG59O1xyXG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xyXG4oZnVuY3Rpb24gKFpvZEZpcnN0UGFydHlUeXBlS2luZCkge1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xyXG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XHJcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxyXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcclxuY2xzLCBwYXJhbXMgPSB7XHJcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcclxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xyXG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcclxuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XHJcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xyXG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcclxuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcclxuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcclxuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XHJcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xyXG5jb25zdCBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xyXG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcclxuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcclxuY29uc3QgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xyXG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xyXG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XHJcbmNvbnN0IG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xyXG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcclxuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xyXG5jb25zdCBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcclxuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XHJcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcclxuY29uc3QgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XHJcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xyXG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcclxuY29uc3QgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xyXG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xyXG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xyXG5jb25zdCBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xyXG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xyXG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xyXG5jb25zdCBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xyXG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XHJcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcclxuY29uc3QgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xyXG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XHJcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcclxuY29uc3Qgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xyXG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcclxuY29uc3QgY29lcmNlID0ge1xyXG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcclxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXHJcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xyXG4gICAgICAgIC4uLmFyZyxcclxuICAgICAgICBjb2VyY2U6IHRydWUsXHJcbiAgICB9KSksXHJcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxyXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxyXG59O1xyXG5jb25zdCBORVZFUiA9IElOVkFMSUQ7XHJcblxyXG52YXIgeiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICAgIF9fcHJvdG9fXzogbnVsbCxcclxuICAgIGRlZmF1bHRFcnJvck1hcDogZXJyb3JNYXAsXHJcbiAgICBzZXRFcnJvck1hcDogc2V0RXJyb3JNYXAsXHJcbiAgICBnZXRFcnJvck1hcDogZ2V0RXJyb3JNYXAsXHJcbiAgICBtYWtlSXNzdWU6IG1ha2VJc3N1ZSxcclxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXHJcbiAgICBhZGRJc3N1ZVRvQ29udGV4dDogYWRkSXNzdWVUb0NvbnRleHQsXHJcbiAgICBQYXJzZVN0YXR1czogUGFyc2VTdGF0dXMsXHJcbiAgICBJTlZBTElEOiBJTlZBTElELFxyXG4gICAgRElSVFk6IERJUlRZLFxyXG4gICAgT0s6IE9LLFxyXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXHJcbiAgICBpc0RpcnR5OiBpc0RpcnR5LFxyXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcclxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXHJcbiAgICBnZXQgdXRpbCAoKSB7IHJldHVybiB1dGlsOyB9LFxyXG4gICAgZ2V0IG9iamVjdFV0aWwgKCkgeyByZXR1cm4gb2JqZWN0VXRpbDsgfSxcclxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXHJcbiAgICBnZXRQYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlLFxyXG4gICAgWm9kVHlwZTogWm9kVHlwZSxcclxuICAgIGRhdGV0aW1lUmVnZXg6IGRhdGV0aW1lUmVnZXgsXHJcbiAgICBab2RTdHJpbmc6IFpvZFN0cmluZyxcclxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxyXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXHJcbiAgICBab2RCb29sZWFuOiBab2RCb29sZWFuLFxyXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcclxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxyXG4gICAgWm9kVW5kZWZpbmVkOiBab2RVbmRlZmluZWQsXHJcbiAgICBab2ROdWxsOiBab2ROdWxsLFxyXG4gICAgWm9kQW55OiBab2RBbnksXHJcbiAgICBab2RVbmtub3duOiBab2RVbmtub3duLFxyXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxyXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcclxuICAgIFpvZEFycmF5OiBab2RBcnJheSxcclxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxyXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxyXG4gICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uOiBab2REaXNjcmltaW5hdGVkVW5pb24sXHJcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcclxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcclxuICAgIFpvZFJlY29yZDogWm9kUmVjb3JkLFxyXG4gICAgWm9kTWFwOiBab2RNYXAsXHJcbiAgICBab2RTZXQ6IFpvZFNldCxcclxuICAgIFpvZEZ1bmN0aW9uOiBab2RGdW5jdGlvbixcclxuICAgIFpvZExhenk6IFpvZExhenksXHJcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxyXG4gICAgWm9kRW51bTogWm9kRW51bSxcclxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXHJcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxyXG4gICAgWm9kRWZmZWN0czogWm9kRWZmZWN0cyxcclxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxyXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxyXG4gICAgWm9kTnVsbGFibGU6IFpvZE51bGxhYmxlLFxyXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcclxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcclxuICAgIFpvZE5hTjogWm9kTmFOLFxyXG4gICAgQlJBTkQ6IEJSQU5ELFxyXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcclxuICAgIFpvZFBpcGVsaW5lOiBab2RQaXBlbGluZSxcclxuICAgIFpvZFJlYWRvbmx5OiBab2RSZWFkb25seSxcclxuICAgIGN1c3RvbTogY3VzdG9tLFxyXG4gICAgU2NoZW1hOiBab2RUeXBlLFxyXG4gICAgWm9kU2NoZW1hOiBab2RUeXBlLFxyXG4gICAgbGF0ZTogbGF0ZSxcclxuICAgIGdldCBab2RGaXJzdFBhcnR5VHlwZUtpbmQgKCkgeyByZXR1cm4gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kOyB9LFxyXG4gICAgY29lcmNlOiBjb2VyY2UsXHJcbiAgICBhbnk6IGFueVR5cGUsXHJcbiAgICBhcnJheTogYXJyYXlUeXBlLFxyXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxyXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXHJcbiAgICBkYXRlOiBkYXRlVHlwZSxcclxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcclxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXHJcbiAgICAnZW51bSc6IGVudW1UeXBlLFxyXG4gICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb25UeXBlLFxyXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcclxuICAgIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uVHlwZSxcclxuICAgIGxhenk6IGxhenlUeXBlLFxyXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXHJcbiAgICBtYXA6IG1hcFR5cGUsXHJcbiAgICBuYW46IG5hblR5cGUsXHJcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcclxuICAgIG5ldmVyOiBuZXZlclR5cGUsXHJcbiAgICAnbnVsbCc6IG51bGxUeXBlLFxyXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcclxuICAgIG51bWJlcjogbnVtYmVyVHlwZSxcclxuICAgIG9iamVjdDogb2JqZWN0VHlwZSxcclxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcclxuICAgIG9udW1iZXI6IG9udW1iZXIsXHJcbiAgICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxyXG4gICAgb3N0cmluZzogb3N0cmluZyxcclxuICAgIHBpcGVsaW5lOiBwaXBlbGluZVR5cGUsXHJcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcclxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxyXG4gICAgcmVjb3JkOiByZWNvcmRUeXBlLFxyXG4gICAgc2V0OiBzZXRUeXBlLFxyXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxyXG4gICAgc3RyaW5nOiBzdHJpbmdUeXBlLFxyXG4gICAgc3ltYm9sOiBzeW1ib2xUeXBlLFxyXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxyXG4gICAgdHVwbGU6IHR1cGxlVHlwZSxcclxuICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWRUeXBlLFxyXG4gICAgdW5pb246IHVuaW9uVHlwZSxcclxuICAgIHVua25vd246IHVua25vd25UeXBlLFxyXG4gICAgJ3ZvaWQnOiB2b2lkVHlwZSxcclxuICAgIE5FVkVSOiBORVZFUixcclxuICAgIFpvZElzc3VlQ29kZTogWm9kSXNzdWVDb2RlLFxyXG4gICAgcXVvdGVsZXNzSnNvbjogcXVvdGVsZXNzSnNvbixcclxuICAgIFpvZEVycm9yOiBab2RFcnJvclxyXG59KTtcclxuXHJcbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIGRhdGV0aW1lUmVnZXgsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zod/lib/index.mjs\n");

/***/ })

};
;